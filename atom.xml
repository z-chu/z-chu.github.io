<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赵成柱的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-06T07:26:39.381Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>z-chu</name>
    <email>zchu8073@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>(转) Android IM 开发小结</title>
    <link href="http://yoursite.com/2017/04/20/Android-IM-Summarize/"/>
    <id>http://yoursite.com/2017/04/20/Android-IM-Summarize/</id>
    <published>2017-04-20T06:30:02.000Z</published>
    <updated>2017-05-06T07:26:39.381Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个 IM 软件，最重要的一个特性就是保证消息的达到率和实时性。达到率受服务器性能和设计协议影响，后面再谈。而实时性则主要取决于客户端进程是否长期存活，连接是否一致保持。由于墙的存在，墙内的 Android 系统是没法用到 GCM 服务的，要实时收到消息推送，就只能靠 App 自己了。也幸好 Android 是一个 “多任务操作系统.真”，我们才能够在墙内也能实时收到微信易信的消息。</p>
<h2 id="进程切分"><a href="#进程切分" class="headerlink" title="进程切分"></a>进程切分</h2><p>在 Android 系统中，App 对于自己应用的生命周期是基本没有控制力，系统能在任意时候将你的进程杀死，且不会发出任何通知，也会在它认为合适的时候把你叫起来。进程前后台切换也同样不会给出任何通知。不过进程的生死控制也还是有一些规矩的，大体上来说就是进程占的资源越多（内存，CPU 时间等等），对于用户越不重要（前台进程-&gt;可视进程-&gt;服务进程-&gt;后台进程-&gt;空进程），越容易被干掉。因此，进程应当尽量小巧，且具有高的优先级。</p>
<p>如果一个应用本身就很小巧的话，一个进程就完全足够了，主线程负责 UI，另起一个后台线程跑一个服务。而如果应用比较庞大的话，将推送服务独立出来则是一个更好的选择。主进程负责用户交互和主要的业务逻辑，占用庞大的资源，当退到后台后，随时被杀死都无所谓。推送进程则仅仅负责与服务器交互，保持最小限度的业务逻辑处理。<br>网络连接和登录状态是绑在一起的，登录之后，同步数据也是必须的操作。因此，登录和同步数据都需要在推送进程中完成，除此之外，其他的业务都交给 UI 进程处理。推送进程收到自己不属于自己的协议时，就将数据扔给 UI 进程处理。</p>
<p>两个进程之间通信方式没有别的选择，只有 AIDL，难点在于接口的设计。IM 业务逻辑复杂，我们不可能为每一个调用实现一个 AIDL 接口，因此肯定会把接口调用打包成控制命令传递。而标识控制命令比较容易想到的方式，是采用类似于 Message 的 what，由我们为每一个控制命令分配一个命令号（或者再加一个子命令号），并指定对应的命令数据格式，接收端根据命令号再将数据反解出来处理。这种方式比较麻烦，且可维护性很差。更优雅的方式是使用远程过程调用，发送端申明业务的调用接口，并在远端实现这些接口，当发送端调用这些接口时，远端直接调用对应接口的实现。除了使用各种第三方框架外，Java 自身的 Proxy 也能实现这个功能。而从推送进程到 UI 进程还有一点不同，UI 进程随时可能会被干掉，AIDL 调用可能会返回失败，此种情况可选择 Intent 方式传递数据，并兼具唤起 UI 进程的功能。<br><a id="more"></a></p>
<h2 id="保活"><a href="#保活" class="headerlink" title="保活"></a>保活</h2><p>保活分为三个方面，一是系统API提供了接口，应用自己就能做的，这是”合法“的，二是利用系统的缺陷，躲开系统的审查，这算是”非法“的，或者是”灰色“的，三就是多个 App 结盟，互相唤醒，这是耍流氓，谁的阵营庞大谁就赢。</p>
<p>第一种主要有系统闹钟，各种事件的 BroadcastReceiver，任务被移除的回调通知等。</p>
<p>第二种已知的就是在 4.4 及以前版本上，使用 native 进程，并将该进程从 davilk 父进程中脱离，挂接到 init 进程上，以此避开系统的查杀。然后在这个 native 进程中，定时唤起应用。为了让这个 native 进程更轻巧，可以使用 exec 的方式启动一个可执行文件，以除掉直接 fork 带入的 Zygote 进程环境。另外，这种方式也被用在监听自己应用被卸载时弹出调查窗口。</p>
<p>第三种方式现在各大互联网公司都在使用，方式很简单，互相调用指定的 Service，或发指定得广播即可。只要你起一个阿里系的 App，其他阿里系的 App 都会被跟着唤起。你启动一个装了友盟 SDK 的 App， 其他装了友盟 SDK 的 App，以及阿里系的 App 都会被跟着唤醒。</p>
<p>通常，第一种是必备，第二种和第三种则会结伴出现，流氓到底。</p>
<h1 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h1><p>消息的实时性的另一个保证是长连接。当然，你也可以用短连接轮询，但这个一般只在网页端短时聊天使用，在 Android 后台无限时轮询没有人能受的了。长连接类型可以选传统的 TCP，也可以使用 比较新的 WebSocket。 使用后一种的好处主要是服务器的，他们一套连接就可以服务好 App 端和 Web 端。</p>
<h2 id="通信协议选择"><a href="#通信协议选择" class="headerlink" title="通信协议选择"></a>通信协议选择</h2><p>IM 的通信协议选择性很多，开源的有 XMPP，MQTT等，使用开源协议的优势在于上手快，资料多。而大部分主流 IM 则一般会设计私有的通信协议。使用私有协议，可以针对自己的业务逻辑，设计出更省流量，效率更高的协议，同时，还能有效保护自己的生态圈，就像 Android 手机装不了苹果系统，易信用户不能给微信用户发消息一样。</p>
<p>私有协议的协议内容和开源协议差不多，可以包含通用的协议头，然后加上负载包体。打包时，为了追求可读性，可以使用文本协议，为了追求省流量，则一般使用二进制协议。</p>
<p>在设计私有协议时，消息必达是一个需要侧重考量的地方。由于移动网络的复杂性，消息在客户端和服务器之间传递是有很大可能被传丢的。当客户端发送消息给服务器时，客户端并不能确保消息一定就会被服务器收到，需要服务器在收到消息后给客户端一个回馈，如果客户端没有收到回馈，就需要在一定超时后重新发送。这里存在一个问题就是有可能服务器已经收到了，但回馈的包被丢掉了，这时就会造成消息重复，为了去重，我们需要为相同的消息分配相同的 uuid，供接收方去重。同样，当服务器将消息转发给接收端时，服务器也不能保证接收端就一定能收到，需要接收端给服务器一个回执，告诉服务器这条消息我已经收到了，你就不要再给我发了。</p>
<h2 id="建立安全连接"><a href="#建立安全连接" class="headerlink" title="建立安全连接"></a>建立安全连接</h2><p>安全性是 IM 软件的另一个硬需求。消息传递时如果通信数据如果被第三方截取，要能保证别人不能获取到真实内容。安全连接的过程可以参考 HTTPS 的方式，由服务器将证书下发给客户端，客户端产生一个对称的密钥，并通过服务器证书加密后交给服务器，之后的通信就全部使用这个对称的密钥来加密。当然，这里有两点需要和 HTTPS 有所区别，第一是证书的获取方式，HTTPS 中是由专门机构去验证证书合法性的，IM 的客户端肯定不会这么去做，为了防止获取证书的过程被人截获，然后篡改证书，可行的方式是直接在客户端安装包中直接把证书打进去，该证书可以随着客户端软件升级一起升级，也可以在加密连接之后通过协议升级。第二个问题是对称加密算法的选择，因为密钥的生命周期是跟随一次连接的，时间并不长，而移动 App 对于电量消耗非常敏感，因此加密算法应尽量选择较为简单的类型，例如 RC4。</p>
<h2 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h2><p>心跳可以分为 TCP 的协议层心跳和 App 的应用层心跳。一般我们都使用应用层心跳，一来便于服务器扩展（比如哪天我们可以换成 UDP 来传），二则是可以更灵活控制心跳间隔。<br>心跳协议仅仅是用来连接保活，其内容应当尽量精简，除了包头中必要的部分，包体的可选包头都不存在。<br>对于不同的网络环境，心跳可以采用不同的时间间隔。在不同网络环境下，间隔的选择可以参考<a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=207243549&amp;idx=1&amp;sn=4ebe4beb8123f1b5ab58810ac8bc5994&amp;scene=4&amp;uin=NzIzMzYwMDIw&amp;key=c468684b929d2be223a2abe8e5afea5d27b0b49b175762424a3878adb02bf95c1e7c56f48afd72f710e6705bd7a84bff&amp;devicetype=webwx&amp;version=70000001&amp;lang=zh_CN&amp;pass_ticket=WmZdOj9MH6ZvvhZIHYiNaVNuQVqJck27LraSAzXS2bDiv%2FN5DgZNNBx0xX%2BvKiRc" target="_blank" rel="external">微信智能心跳方案</a>。</p>
<h2 id="断线重连"><a href="#断线重连" class="headerlink" title="断线重连"></a>断线重连</h2><p>客户端掉线的原因无非两种，客户端网络挂了，服务器挂了。客户端网络挂了也分两种，一种是本机就能感知到的网络连接断开，另一种是本机网络是好的，但互联网连接是不同的，对应到 Android API上，就是 NetworkInfo 的 isAvailable 和 isConnected。当然这个地方的 isConnected 不一定可靠，因为它是靠连制定服务器来确定的，那个服务器谁知道有没有问题。</p>
<p>掉线后，根据不同的状态需要选择不同的重连间隔。如果是本地网络出错，并不需要定时去重连，这时只需要监听网络状态，等到网络恢复后重连即可。如果网络变化非常频繁，特别是 App 处在后台运行时，对于重连也可以加上一定的频率控制，在保证一定消息实时性的同时，避免造成过多的电量消耗。</p>
<p>而如果掉线是因为本机网络连不通互联网，或者是服务器挂了，重连间隔的选择就非常重要了。<br>首先，如果程序是在前台，用户正在使用我们的 App，重连间隔应更加频繁，使得用户反馈更加及时，如果程序处于后台运行，则为了省电，可以适当延长重连间隔。<br>其次，随着重连次数的增加，说明服务器短时间内恢复的可能性逐渐降低，重连间隔也应随之延长（倍数增长）。但应该设置一个最大的重连间隔，当到达最大间隔时，不再增加。<br>第三，重连间隔的增加不应当是固定的，而应该增加一个随机退避策略。以免如果是服务器宕机造成掉线，所有客户端的重连时间点都是一样的，当服务器恢复后，同一个时间点所有客户端同时连接服务器，造成服务器不堪拥堵，再次宕机。活生生的例子请参考环信去年的宕机时间。<br>总结起来，重连间隔可表述如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">interval</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> maxCount = isForeground() ? MAX_COUNT_FOREGROUND : MAX_COUNT_BAKGROUND;</div><div class="line">	count = Math.min(count, maxCount);</div><div class="line"></div><div class="line">	<span class="keyword">int</span> minInterval = BASE * <span class="number">2</span>^(count - <span class="number">1</span>);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> minInterval + <span class="keyword">new</span> Random().nextInt(minInterval);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="多媒体数据管理"><a href="#多媒体数据管理" class="headerlink" title="多媒体数据管理"></a>多媒体数据管理</h1><p>IM 系统中另一个重头戏是多媒体数据。由于移动网络比较慢，流量又贵，在移动端针对这些问题必须要做一些处理。在上传时，尽量减少上传时间，在下载时，能让用户尽快看到内容。同时，尽量节省流量，减少不必要的流量消耗。<br>文本消息因为比较小，可以直接通过长连接传输。但对于多媒体文件，通过长连接来传输则不合适，长连接服务器不会对大文件传输做针对性优化，大量的多媒体文件数据会直接抢占其他信令消息和文本消息的贷款资源。因此，多媒体消息会通过另外的通道，到专门的文件服务器存取。<br>在下载时，对于不同的网络环境，可以采用不同的预取策略。在 WiFi 环境下，由于无需考虑流量问题，在收到消息后，我们就能立即把包含的多媒体文件下载下来。而在移动网络中，则应当等到用户真正看到该多媒体消息时，才去下载。</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>上传时，现在手机摄像头的像素动辄上千万，一张图片随随便便就好几M，然而，通过 IM 软件传输的图片，通常对于质量要求并不会太高，如果我们直接将好几M的图片直接上传，往往费力又不讨好。在上传之前，将图片像素降低，并进行压缩，可以明显的减少上传转菊花的时间，减少用户流量消耗。如果用户确实要求图片质量，则提供一个原图选项。<br>如果是使用 http 上传，大文件会被分成多个数据块上传，前一个数据块传输成功后，再传输下一个。断线重传时，也是以数据块作为最小重传单元。针对不同的网络类型，数据块大小不同。在较好网络下(wifi/4g/3g)，数据块可以比较大，这样可以减少交互时间，加快传输熟读，而在弱网环境，数据块应当设置的比较小，以降低传输失败概率，减少重传流量消耗。<br>使用 http 上传的另一个优化技术是使用 pipeline。在不使用 pipeline 时，上传一个数据块需要等到前一个数据块传输成功才行，数据通道是单工的。使用pipeline则可以将数据通道变为双工的，一个数据块传输完成后，不必等到回包，就能直接上传下一个数据包，能节省一次数据回包延时。</p>
<p>下载时，在消息展示区显示的通常只是一个很小的图片，这时候只需要下载对应大小的缩略图即可，无需下载原图。甚至，这里可以将比缩略图更小的图片二进制数据直接放到消息体中下发，并展示给用户一个高斯模糊后的效果图，在保证最低可用的情况下，减少用户等待时间，提高用户体验。</p>
<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p>对于不同的网络环境，采取不同质量的语音编码算法，在较好网络时，使用高质量语音，而在弱网环境下，则使用较低质量，优先保证可用性。<br>为了减少用户等待时间，还可以采取边录边传的策略。由于录音时间比较长，在录制的过程中，我们就可以将录好的部分先传到服务器，等到录音完成，只需要上传最后一个数据包，并告知服务器录音完成即可，基本上可以做到录完即传完，无需等待。</p>
<p>语音消息没有缩略图，因此语音下载基本就只能实打实的将原始文件下载下来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个 IM 软件，最重要的一个特性就是保证消息的达到率和实时性。达到率受服务器性能和设计协议影响，后面再谈。而实时性则主要取决于客户端进程是否长期存活，连接是否一致保持。由于墙的存在，墙内的 Android 系统是没法用到 GCM 服务的，要实时收到消息推送，就只能靠 App 自己了。也幸好 Android 是一个 “多任务操作系统.真”，我们才能够在墙内也能实时收到微信易信的消息。&lt;/p&gt;
&lt;h2 id=&quot;进程切分&quot;&gt;&lt;a href=&quot;#进程切分&quot; class=&quot;headerlink&quot; title=&quot;进程切分&quot;&gt;&lt;/a&gt;进程切分&lt;/h2&gt;&lt;p&gt;在 Android 系统中，App 对于自己应用的生命周期是基本没有控制力，系统能在任意时候将你的进程杀死，且不会发出任何通知，也会在它认为合适的时候把你叫起来。进程前后台切换也同样不会给出任何通知。不过进程的生死控制也还是有一些规矩的，大体上来说就是进程占的资源越多（内存，CPU 时间等等），对于用户越不重要（前台进程-&amp;gt;可视进程-&amp;gt;服务进程-&amp;gt;后台进程-&amp;gt;空进程），越容易被干掉。因此，进程应当尽量小巧，且具有高的优先级。&lt;/p&gt;
&lt;p&gt;如果一个应用本身就很小巧的话，一个进程就完全足够了，主线程负责 UI，另起一个后台线程跑一个服务。而如果应用比较庞大的话，将推送服务独立出来则是一个更好的选择。主进程负责用户交互和主要的业务逻辑，占用庞大的资源，当退到后台后，随时被杀死都无所谓。推送进程则仅仅负责与服务器交互，保持最小限度的业务逻辑处理。&lt;br&gt;网络连接和登录状态是绑在一起的，登录之后，同步数据也是必须的操作。因此，登录和同步数据都需要在推送进程中完成，除此之外，其他的业务都交给 UI 进程处理。推送进程收到自己不属于自己的协议时，就将数据扔给 UI 进程处理。&lt;/p&gt;
&lt;p&gt;两个进程之间通信方式没有别的选择，只有 AIDL，难点在于接口的设计。IM 业务逻辑复杂，我们不可能为每一个调用实现一个 AIDL 接口，因此肯定会把接口调用打包成控制命令传递。而标识控制命令比较容易想到的方式，是采用类似于 Message 的 what，由我们为每一个控制命令分配一个命令号（或者再加一个子命令号），并指定对应的命令数据格式，接收端根据命令号再将数据反解出来处理。这种方式比较麻烦，且可维护性很差。更优雅的方式是使用远程过程调用，发送端申明业务的调用接口，并在远端实现这些接口，当发送端调用这些接口时，远端直接调用对应接口的实现。除了使用各种第三方框架外，Java 自身的 Proxy 也能实现这个功能。而从推送进程到 UI 进程还有一点不同，UI 进程随时可能会被干掉，AIDL 调用可能会返回失败，此种情况可选择 Intent 方式传递数据，并兼具唤起 UI 进程的功能。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git 常用命令合集</title>
    <link href="http://yoursite.com/2017/03/05/git/"/>
    <id>http://yoursite.com/2017/03/05/git/</id>
    <published>2017-03-04T16:02:22.000Z</published>
    <updated>2017-03-04T17:01:22.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><ul>
<li><p>创建本地仓库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init</div></pre></td></tr></table></figure>
</li>
<li><p>获取远程仓库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone [url]</div></pre></td></tr></table></figure>
<p>   例：<code>git clone https://github.com/you/yourpro.git</code></p>
</li>
</ul>
<h2 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h2><ul>
<li><p>添加一个新的 remote 远程仓库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add [remote-name] [url]</div></pre></td></tr></table></figure>
<p>例：<code>git remote add origin https://github.com/you/yourpro.git</code> ，origin：相当于该远程仓库的别名</p>
<a id="more"></a>
</li>
<li><p>列出所有 remote 的别名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote</div></pre></td></tr></table></figure>
</li>
<li><p>列出所有 remote 的 url：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote -v</div></pre></td></tr></table></figure>
</li>
<li><p>删除一个 remote：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote rm [name]</div></pre></td></tr></table></figure>
</li>
<li><p>重命名 remote：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote rename [old-name] [new-name]</div></pre></td></tr></table></figure>
</li>
<li><p>修改远程仓库地址：</p>
<ul>
<li><p>直接修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote set-url origin [url]</div></pre></td></tr></table></figure>
<p> 例如：<code>git remote set-url origin https://github.com/you/yourpro.git</code></p>
</li>
<li><p>先删后加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git remote rm origin</div><div class="line">git remote add origin [url]</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><ul>
<li><p>从本地仓库中添加新的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add .               // 添加所有文件</div><div class="line">git add file.txt        // 添加指定文件</div></pre></td></tr></table></figure>
</li>
<li><p>从本地仓库中删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git rm file.txt         // 从版本库中移除，删除文件</div><div class="line">git rm file.txt -cached // 从版本库中移除，不删除原始文件</div><div class="line">git rm -r xxx           // 从版本库中删除指定文件夹</div></pre></td></tr></table></figure>
</li>
<li><p>提交，把内容提交到 HEAD 里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m &quot;注释&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>撤销：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git revert HEAD     // 撤销最近的一个提交</div><div class="line">git reset --mixed   // 取消 commit + add</div><div class="line">git reset --soft    // 取消 commit</div><div class="line">git reset --hard    // 取消 commit + add + local working</div></pre></td></tr></table></figure>
</li>
<li><p>把本地提交 push 到远程服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git push [remote-name] [loca-branch]:[remote-branch]</div><div class="line">例：git push origin master:master</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="更新代码"><a href="#更新代码" class="headerlink" title="更新代码"></a>更新代码</h2><ul>
<li><p>查看状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git status</div></pre></td></tr></table></figure>
</li>
<li><p>从远程库中下载新的改动-方式1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git fetch [remote-name]/[branch]</div></pre></td></tr></table></figure>
</li>
<li><p>从远程库中下载新的改动-方式2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git pull [remote-name] [branch]</div></pre></td></tr></table></figure>
<p>  例：<code>git pull origin master</code><br>  pull = fetch + merge</p>
</li>
<li><p>合并下载的改动到分支-方式1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git merge [remote-name]/[branch]</div><div class="line">解决冲突...</div><div class="line">git add .</div><div class="line">git commit -m&apos;fix conflict&apos;</div></pre></td></tr></table></figure>
</li>
<li><p>合并下载的改动到分支-方式2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git rebase [remote-name]/[branch]</div><div class="line">解决冲突...</div><div class="line">git add .</div><div class="line">git rebase --continue</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 列出分支</div><div class="line">git branch</div><div class="line">// 创建一个新的分支</div><div class="line">git branch (branch-name)</div><div class="line">// 删除一个分支</div><div class="line">git branch -d (branch-nam)</div><div class="line">// 删除 remote 的分支</div><div class="line">git push (remote-name) :(remote-branch)</div><div class="line">// 切换到一个分支</div><div class="line">git checkout [branch-name]</div><div class="line">// 创建并切换到该分支</div><div class="line">git checkout -b [branch-name]</div></pre></td></tr></table></figure>
<h2 id="与github建立ssh通信，让Git操作免去输入密码的繁琐"><a href="#与github建立ssh通信，让Git操作免去输入密码的繁琐" class="headerlink" title="与github建立ssh通信，让Git操作免去输入密码的繁琐"></a>与github建立ssh通信，让Git操作免去输入密码的繁琐</h2><ol>
<li><p>首先呢，我们先建立ssh密匙。</p>
<blockquote>
<p>ssh key must begin with ‘ssh-ed25519’, ‘ssh-rsa’, ‘ssh-dss’, ‘ecdsa-sha2-nistp256’, ‘ecdsa-sha2-nistp384’, or ‘ecdsa-sha2-nistp521’.  – from github</p>
</blockquote>
<p>根据以上文段我们可以知道github所支持的ssh密匙类型，这里我们创建ssh-rsa密匙。</p>
</li>
<li><p>在command line 中输入以下指令:<code>ssh-keygen -t rsa</code>去创建一个ssh-rsa密匙。如果你并不需要为你的密匙创建密码和修改名字，那么就一路回车就OK，如果你需要，请您自行Google翻译，因为只是英文问题。</p>
<blockquote>
<p>$ ssh-keygen -t rsa<br>Generating public/private rsa key pair.<br>Enter file in which to save the key (/c/Users/Liang Guan Quan/.ssh/id_rsa)<br>您可以根据括号中的路径来判断你的.ssh文件放在了什么地方</p>
</blockquote>
</li>
<li><p>到 <a href="https://github.com/settings/keys" target="_blank" rel="external">https://github.com/settings/keys</a> 这个地址中去添加一个新的SSH key，然后把你的xx.pub文件下的内容文本都复制到Key文本域中，然后就可以提交了。</p>
</li>
<li>添加完成之后 我们用<code>ssh git@github.com</code> 命令来连通一下github，如果你在response里面看到了你github账号名，那么就说明配置成功了。  <em>let’s enjoy github ;)</em></li>
</ol>
<h2 id="gitignore"><a href="#gitignore" class="headerlink" title="gitignore"></a>gitignore</h2><p>在本地仓库根目录创建 .gitignore 文件。Win7 下不能直接创建，可以创建 “.gitignore.” 文件，后面的标点自动被忽略；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/.idea          // 过滤指定文件夹</div><div class="line">/fd/*           // 忽略根目录下的 /fd/ 目录的全部内容</div><div class="line">*.iml           // 过滤指定的所有文件</div><div class="line">!.gitignore     // 不忽略该文件</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建&quot;&gt;&lt;a href=&quot;#创建&quot; class=&quot;headerlink&quot; title=&quot;创建&quot;&gt;&lt;/a&gt;创建&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建本地仓库：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git init&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;获取远程仓库：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git clone [url]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;   例：&lt;code&gt;git clone https://github.com/you/yourpro.git&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;远程&quot;&gt;&lt;a href=&quot;#远程&quot; class=&quot;headerlink&quot; title=&quot;远程&quot;&gt;&lt;/a&gt;远程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;添加一个新的 remote 远程仓库：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git remote add [remote-name] [url]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;例：&lt;code&gt;git remote add origin https://github.com/you/yourpro.git&lt;/code&gt; ，origin：相当于该远程仓库的别名&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Java到底是不是一种纯面向对象语言</title>
    <link href="http://yoursite.com/2017/02/23/java-1/"/>
    <id>http://yoursite.com/2017/02/23/java-1/</id>
    <published>2017-02-23T15:22:20.000Z</published>
    <updated>2017-02-23T15:23:33.576Z</updated>
    
    <content type="html"><![CDATA[<p>Java到底是不是一种纯面向对象语言？<br>静态内容和基本类型它们到底是不是一个对象？<br>下面让我们深入到Java的世界，一步一步证实它！</p>
<h2 id="旧的认知"><a href="#旧的认知" class="headerlink" title="旧的认知"></a>旧的认知</h2><p>在我刚开始学习 Java 的时候，我从书本里知道了 Java 是遵循 “面向对象编程范式”的。在Java世界内一切都是对象，甚至包括字符串（String）这些都是对象（在 C 语言中，字符串是字符数组），那时候，我认为 Java是一种面向对象的语言。</p>
<p>但在后来，我在互联网站上陆续看到不少开发者说 “Java实际上不是纯粹的面向对象，因为并不是所有的东西在 Java 世界都是一个对象”。</p>
<p><strong>他们很多的论点都可以概括为以下两点：</strong></p>
<ul>
<li>所有的静态内容（ static 关键修饰的变量和方法）不属于任何对象，所以这些是非对象的东西。</li>
<li>所有基本类型（char，boolean，byte，short，int，long，float，double）都不是对象，因为我们不能做类似正常对象的所具有的操作（例如：使用“.”来访问对象的属性和方法）。</li>
</ul>
<p>在那时，由于个人知识经验储备有限，我又很容地相信上面的论点，并且也开始认为 “Java 不是纯粹的面向对象编程语言”。</p>
<a id="more"></a>
<h2 id="新的发现"><a href="#新的发现" class="headerlink" title="新的发现"></a>新的发现</h2><p><strong>JVM 在创建对象的时候，实际上会创建两个对象：</strong></p>
<ul>
<li>一个是实例对象</li>
<li>另一个是Class 对象。该 Class 对象在JVM内仅仅会装载一次，该类的静态方法和静态属性也一同装载，JVM使用该 Class 对象来创建具体的实例对象（如上面的对象）。</li>
</ul>
<p>例如，在下面的 Java 语句中，将有两个对象被创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Employee emp = <span class="keyword">new</span> Employee();</div></pre></td></tr></table></figure>
<p>一个是实例对象 emp ；另一个则是 Class对象，我们可以通过 Employee.class 引用到它；这个 Class 对象拥有所有的这个类定义的静态变量和静态方法，同时，如果我们访问 通过 emp 对象来访问静态内容，会发现它其实指向的对象就是 Employee.class .</p>
<p>这也揭开了另一个迷：<br><strong>为什么静态内容在一个对象中（不管是emp还是emp2）改变了，在另一个对象中也同时改变，因为这两个对象改变的都是在 Employee.class 同一个对象里面的内容。</strong></p>
<p><strong>现在，上面说到的第一个论点我们要取消了。因为，静态内容确实被证实属于一个对象。</strong></p>
<p>但是我们还要确认第二个论点：正如早前提到的，原始类型在Java中不是对象，它们无法做类似对象的操作。为了解决这个问题，Java 官方为每一个原始类型推出了对应的包装类（比如：Integer 对应 int，Long 对应 long，Character 对应 char），所以，其实现在我们可以为原始类型创建一个包装对象，同时对它们做对象相关的操作。并且，由于自动拆装箱，我们可以把一个原始类型值赋值给它对应的包装类的引用。但是我们仍然不能对这些原始类型做对象的操作——我们需要创建对应包装类的对象。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Integer obj = <span class="keyword">new</span> Integer(<span class="number">5</span>); <span class="comment">// here we can do i.toString();</span></div><div class="line"><span class="keyword">int</span> i = <span class="number">5</span>; <span class="comment">// but we can't do i.toString() here</span></div></pre></td></tr></table></figure>
<p>到目前为止，从一个最终用户的角度上来看的，我们可以确认 “原始类别不是对象”。（ Java开发人员是Java的最终用户，因为我们正在使用它，而不是创造它 ）。</p>
<p>如果站在JVM的视角，会有新的发现：</p>
<p>其实，在JVM看来它把所有的 “原始类型” 都是当作对象处理” ，要证明这一点可以通过 Class类的源代码 或者 Javadoc中Class类的说明。</p>
<p>根据 java.lang.Class 类的源代码，该类的注释是：</p>
<p>Java官方描述：</p>
<blockquote>
<p>Instances of the class Class represent classes and interfaces in a running Java application. An enum is a kind of class and an annotation is a kind of interface. Every array also belongs to a class that is reflected as a Class object that is shared by all arrays with the same element type and number of dimensions. The primitive Java types (boolean, byte, char, short, int, long, float, and double), and the keyword void are also represented as Class objects.</p>
</blockquote>
<p>参考译文：</p>
<blockquote>
<p>Class类的实例表示正在运行的Java应用程序的类和接口。像枚举是一种类,注解则是一种接口。每个数组也属于被反射作为由具有相同的元素类型和尺寸的数目的所有阵列共享一类对象的类。原始的Java类型（boolean, byte, char, short, int, long, float, and double）和关键字void也表示为Class对象。</p>
</blockquote>
<p>同时也根据Javadoc中对Class.isPrimitive()方法的定义，来判断</p>
<p>Java官方描述：</p>
<blockquote>
<p>public boolean isPrimitive()<br>Determines if the specified Class object represents a primitive type.<br>There are nine predefined Class objects to represent the eight primitive types and void. These are created by the Java Virtual Machine, and have the same names as t he primitive types that they represent, namely boolean,byte, char, short, int, long, float, and double.<br>These objects may only be accessed via the following public static final variables, and are the only Class objects for which this method returns true.<br>Returns:<br>true if and only if this class represents a primitive type<br>Since:<br>JDK1.1</p>
</blockquote>
<p>参考翻译：</p>
<blockquote>
<p>public boolean isPrimitive()<br>判断指定的Class对象是否代表一个基本类型。<br>一共有9种设定好的Class对象来表示对应的基本类型和void关键字。这些对象都是由JVM创建的。…<br>return<br>当且仅当该类表示一个真正的基本类型</p>
</blockquote>
<p>以上都说明，在JVM内部，其实原始类型就是对象。<br>当你打开 Javadoc 对 Class 类的定义中，通过 “CTRL＋F ” 查找关键字 “primitive”， 将会发现证据在表面 “在JVM里，它把基本类型当作对象来处理的”。<br>我们可以再来看一个例子： Integer.TYPE，在这部分文档清晰记录着：<br>Java官方描述：</p>
<blockquote>
<p>public static final Class<integer> TYPE<br>The Class instance representing the primitive type int.</integer></p>
</blockquote>
<p>以上都说明，在JVM内部，其实原始类型就是对象。</p>
<p>那么，既然说 “JVM”会为所有的基本类型创建一个对象，那我们为什么还那么常用 “原始类型”， 而不是直接使用对应的包装类对象呢？</p>
<p>这是因为，为 “原始类型” 创建的对象，在JVM内部是很轻量级的，相对与我们直接创建的对应包装类对象做了许多优化； 也正因为轻量的缘故，这些原始类的功能就比较少（例如我们不能调用其内部的方法，因为他们内部已经优化成没有方法了）</p>
<p>使用实际的例子来说明，为什么我们更应该使用 “原始类型”：</p>
<p>“原始类型”有更快的速度（例如，下面的代码执行，在我们的机器上需要9秒，但当我把 Long 改成 long 之后，0秒内就完成了）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> millis = System.currentTimeMillis();</div><div class="line">    Long sum = <span class="number">0L</span>; <span class="comment">// uses Long, not long</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++) &#123;</div><div class="line">        sum += i;</div><div class="line">    &#125;</div><div class="line">    System.out.println(sum);</div><div class="line">    System.out.println((System.currentTimeMillis() - millis) / <span class="number">1000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>“原始类型”允许我们直接使用 “==”来进行比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Integer(<span class="number">3</span>) == <span class="keyword">new</span> Integer(<span class="number">3</span>); <span class="comment">// false</span></div><div class="line"><span class="keyword">new</span> Integer(<span class="number">100</span>) == <span class="keyword">new</span> Integer(<span class="number">100</span>); <span class="comment">// false</span></div><div class="line">Integer.valueOf(<span class="number">5</span>) == Integer.valueOf(<span class="number">5</span>); <span class="comment">//true</span></div><div class="line">Integer.valueOf(<span class="number">200</span>) == Integer.valueOf(<span class="number">200</span>); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>我们注意看第四句，输出结果确实为 “false” 。这个是因在 [-128; 127] 这个区间的265个整数会被 JVM 缓存存放， 所以在这个区间， JVM返回相同的对象；然而，超出这个区间， JVM就不再有缓存了，将会创建新的对象，所以结果是不等的。</p>
<p>所以总结一下是：<strong> 在JVM内部，原始类型就是被当作对象来处理的。但是我们开发者直接把 “原始类型” 当作对象使用，开发者应该使用对应的包装来。</strong></p>
<p><strong>以上就证实了Java确实是一个纯粹的面向对象语言</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java到底是不是一种纯面向对象语言？&lt;br&gt;静态内容和基本类型它们到底是不是一个对象？&lt;br&gt;下面让我们深入到Java的世界，一步一步证实它！&lt;/p&gt;
&lt;h2 id=&quot;旧的认知&quot;&gt;&lt;a href=&quot;#旧的认知&quot; class=&quot;headerlink&quot; title=&quot;旧的认知&quot;&gt;&lt;/a&gt;旧的认知&lt;/h2&gt;&lt;p&gt;在我刚开始学习 Java 的时候，我从书本里知道了 Java 是遵循 “面向对象编程范式”的。在Java世界内一切都是对象，甚至包括字符串（String）这些都是对象（在 C 语言中，字符串是字符数组），那时候，我认为 Java是一种面向对象的语言。&lt;/p&gt;
&lt;p&gt;但在后来，我在互联网站上陆续看到不少开发者说 “Java实际上不是纯粹的面向对象，因为并不是所有的东西在 Java 世界都是一个对象”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;他们很多的论点都可以概括为以下两点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有的静态内容（ static 关键修饰的变量和方法）不属于任何对象，所以这些是非对象的东西。&lt;/li&gt;
&lt;li&gt;所有基本类型（char，boolean，byte，short，int，long，float，double）都不是对象，因为我们不能做类似正常对象的所具有的操作（例如：使用“.”来访问对象的属性和方法）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在那时，由于个人知识经验储备有限，我又很容地相信上面的论点，并且也开始认为 “Java 不是纯粹的面向对象编程语言”。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android快速发布项目到jcenter</title>
    <link href="http://yoursite.com/2017/02/14/release-JCenter/"/>
    <id>http://yoursite.com/2017/02/14/release-JCenter/</id>
    <published>2017-02-13T16:06:54.000Z</published>
    <updated>2017-02-13T16:12:29.563Z</updated>
    
    <content type="html"><![CDATA[<p>最近在整理项目的时候，想要上传至Jcenter，可以让大家一句代码就可以引入。就在网上寻找，然而网上有些方法实在是太麻烦，故写此篇文章将心酸历程写下，让各位老司机少走弯路，快速发布</p>
<h2 id="注册Bintray账号"><a href="#注册Bintray账号" class="headerlink" title="注册Bintray账号"></a>注册Bintray账号</h2><p>个人注册 Bintray 地址：<a href="https://bintray.com/signup/oss" target="_blank" rel="external">https://bintray.com/signup/oss</a><br>不要去 <a href="https://bintray.com/login" target="_blank" rel="external">https://bintray.com/login</a> 注册，这个千万不能搞错。<br><strong>注意一下邮箱问题：不能用QQ，163等，推荐用Gmail</strong>，国内用户可以使用github的账号进行登陆完成注册，也要注意邮箱问题。</p>
<p><strong>获取信息：</strong>登陆后在首页右上角点击用户名进入个人主页，然后点击用户名下面的Edit Profile进入个人信息编辑页面，接下来点击页面左边列表的最后一项API Key，保存下来，因为将项目发布到JCenter时会用到它。</p>
<p><img src="http://7xq7yd.com1.z0.glb.clouddn.com/Jcenter-API-key.png" alt="获取 API key"></p>
<a id="more"></a>
<h2 id="Add-New-Repository"><a href="#Add-New-Repository" class="headerlink" title="Add New Repository"></a>Add New Repository</h2><p>注册完之后，第一件事情是”Add New Repository”。</p>
<p><img src="http://7xq7yd.com1.z0.glb.clouddn.com/Add%20New%20Repository.png" alt="Add New Repository"></p>
<p>点击之后就是创建Repository了，记得下图中红框的位置一定要填小写的maven，否则无法发布上去:</p>
<p><img src="http://7xq7yd.com1.z0.glb.clouddn.com/Create%20Respository.png" alt=""></p>
<p>Repository创建完之后，我们就可以正式进入发布项目之旅了。</p>
<h2 id="Android项目的发布步骤"><a href="#Android项目的发布步骤" class="headerlink" title="Android项目的发布步骤"></a>Android项目的发布步骤</h2><h3 id="1-修改根目录下build-gradle"><a href="#1-修改根目录下build-gradle" class="headerlink" title="1. 修改根目录下build.gradle"></a>1. 修改根目录下build.gradle</h3><p>先添加<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line">    dependencies &#123;</div><div class="line">        ...</div><div class="line">        classpath <span class="string">'com.novoda:bintray-release:+'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以及<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">allprojects &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//加上这些</span></div><div class="line">    tasks.withType(Javadoc) &#123;</div><div class="line">        options&#123; encoding <span class="string">"UTF-8"</span></div><div class="line">            charSet <span class="string">'UTF-8'</span></div><div class="line">            links <span class="string">"http://docs.oracle.com/javase/7/docs/api"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-对需要发布的module，修改build-gradle"><a href="#2-对需要发布的module，修改build-gradle" class="headerlink" title="2.对需要发布的module，修改build.gradle"></a>2.对需要发布的module，修改build.gradle</h3><p>先添加插件<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apply <span class="string">plugin:</span> <span class="string">'com.novoda.bintray-release'</span></div></pre></td></tr></table></figure></p>
<p>再加上publish</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">allprojects &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//加上这些</span></div><div class="line">    tasks.withType(Javadoc) &#123;</div><div class="line">        options&#123; encoding <span class="string">"UTF-8"</span></div><div class="line">            charSet <span class="string">'UTF-8'</span></div><div class="line">            links <span class="string">"http://docs.oracle.com/javase/7/docs/api"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">publish&#123;</div><div class="line">    userOrg = <span class="string">'zchu'</span> <span class="comment">// Bintray 账号名</span></div><div class="line">    groupId = <span class="string">'com.zchu'</span></div><div class="line">    artifactId = <span class="string">'zlog'</span></div><div class="line">    publishVersion = <span class="string">'1.0.0'</span></div><div class="line">    desc = <span class="string">'This is a log print library for android'</span> </div><div class="line">    website = <span class="string">'https://github.com/z-chu/ZLog'</span> <span class="comment">//github 地址</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假如 JCenter 审核通过，就可以用多种方式添加该库了。<br>使用gradle添加该库：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile <span class="string">'com.zchu:zlog:1.0.0'</span></div></pre></td></tr></table></figure></p>
<p>使用maven添加该库：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">  &lt;groupId&gt;com.zchu&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;zlog&lt;/artifactId&gt;</div><div class="line">  &lt;version&gt;1.0.0&lt;/version&gt;</div><div class="line">  &lt;type&gt;pom&lt;/type&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<h3 id="3-发布"><a href="#3-发布" class="headerlink" title="3. 发布"></a>3. 发布</h3><p>执行下面的语句</p>
<p><code>./gradlew clean build bintrayUpload -PbintrayUser={Bintray的用户名} -PbintrayKey={API Key} -PdryRun=false</code></p>
<h3 id="4-发布完之后"><a href="#4-发布完之后" class="headerlink" title="4.发布完之后"></a>4.发布完之后</h3><p>不是执行完上述的语句就算完了，还需要通过 JCenter 的审核。</p>
<p>当然不通过审核也是可以使用的，在根目录的build.gradle中添加形如下面的脚本<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">allprojects &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">        maven&#123;url <span class="string">'https://dl.bintray.com/zchu/maven/'</span>&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最为重要的是下面这一句，但是通过审核的话完全不需要添加这一句。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">maven&#123;url <span class="string">'https://dl.bintray.com/zchu/maven/'</span>&#125;</div></pre></td></tr></table></figure>
<p>所以，我们需要通过JCenter审核，否则没有意义。<br><img src="http://7xq7yd.com1.z0.glb.clouddn.com/add%20to%20JCenter.PNG" alt="add to JCenter"></p>
<h3 id="5-审核通过"><a href="#5-审核通过" class="headerlink" title="5.审核通过"></a>5.审核通过</h3><p>JCenter 会通过邮件和站内消息的形式通知到你，一般情况是几个小时之后，审核通过后，就可以尽情地在项目中使用了。</p>
<p><img src="http://7xq7yd.com1.z0.glb.clouddn.com/%E5%8F%91%E5%B8%83%E6%88%90%E5%8A%9F.PNG" alt="发布成功"></p>
<h3 id="6-版本更新"><a href="#6-版本更新" class="headerlink" title="6.版本更新"></a>6.版本更新</h3><p>发布新版本时，必须修改publish的publishVersion且高于原先的版本号。如果publishVersion已经存在，上传时会报错并给出如下类似的提示,除非删除原来的版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">* What went wrong:</div><div class="line">Execution failed for task &apos;:saf-aop:bintrayUpload&apos;.</div><div class="line">&gt; Could not upload to &apos;https://api.bintray.com/content/fengzhizi715/maven/saf-aop/1.0.0/com/safframework/saf-aop/1.0.0/saf-aop-1.0.0-sources.jar&apos;: HTTP/1.1 409 Conflict [message:Unable to upload files: An artifact with the path &apos;com/safframework/saf-aop/1.0.0/saf-aop-1.0.0-sources.jar&apos; already exists]</div><div class="line"></div><div class="line">* Try:</div><div class="line">Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.</div><div class="line"></div><div class="line">BUILD FAILED</div></pre></td></tr></table></figure></p>
<p>上传完成后，点击下图按钮即可。</p>
<p><img src="http://7xq7yd.com1.z0.glb.clouddn.com/%E6%9B%B4%E6%96%B0%E7%89%88%E6%9C%AC.png" alt="更新版本"></p>
<p>更新的审核比较快，稍等一下就行了。</p>
<p>好了，教程到此结束了，是不是 so easy !呢？？？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在整理项目的时候，想要上传至Jcenter，可以让大家一句代码就可以引入。就在网上寻找，然而网上有些方法实在是太麻烦，故写此篇文章将心酸历程写下，让各位老司机少走弯路，快速发布&lt;/p&gt;
&lt;h2 id=&quot;注册Bintray账号&quot;&gt;&lt;a href=&quot;#注册Bintray账号&quot; class=&quot;headerlink&quot; title=&quot;注册Bintray账号&quot;&gt;&lt;/a&gt;注册Bintray账号&lt;/h2&gt;&lt;p&gt;个人注册 Bintray 地址：&lt;a href=&quot;https://bintray.com/signup/oss&quot;&gt;https://bintray.com/signup/oss&lt;/a&gt;&lt;br&gt;不要去 &lt;a href=&quot;https://bintray.com/login&quot;&gt;https://bintray.com/login&lt;/a&gt; 注册，这个千万不能搞错。&lt;br&gt;&lt;strong&gt;注意一下邮箱问题：不能用QQ，163等，推荐用Gmail&lt;/strong&gt;，国内用户可以使用github的账号进行登陆完成注册，也要注意邮箱问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取信息：&lt;/strong&gt;登陆后在首页右上角点击用户名进入个人主页，然后点击用户名下面的Edit Profile进入个人信息编辑页面，接下来点击页面左边列表的最后一项API Key，保存下来，因为将项目发布到JCenter时会用到它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xq7yd.com1.z0.glb.clouddn.com/Jcenter-API-key.png&quot; alt=&quot;获取 API key&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>RecycleView4种定位滚动方式演示</title>
    <link href="http://yoursite.com/2017/02/11/RecyclerView-Scroll/"/>
    <id>http://yoursite.com/2017/02/11/RecyclerView-Scroll/</id>
    <published>2017-02-11T09:35:14.000Z</published>
    <updated>2017-02-11T09:37:22.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>相信大家在项目中使用RecyclerView时，经常会遇到这样的需求：<br>将RecyclerView滑动到指定位置，或者检索RecyclerView的某一项（各个项的高度不确定），然后定位滚动这到一项，将它显示。</p>
<p>下面就讲解4种RecyclerView定位滚动的方式及具体效果演示。</p>
<h2 id="scrollBy"><a href="#scrollBy" class="headerlink" title="scrollBy"></a>scrollBy</h2><p><img src="http://7xq7yd.com1.z0.glb.clouddn.com/RecycleView-ScrollBy.gif" alt="recyclerView.scrollBy(x, y)"></p>
<p>使用：<code>recyclerView.scrollBy(x, y)</code></p>
<p><code>scrollBy(x, y)</code>这个方法是自己去控制移动的距离，单位是像素,所以在使用<code>scrollBy(x, y)</code>需要自己去计算移动的高度或宽度。</p>
<a id="more"></a>
<h2 id="scrollToPosition"><a href="#scrollToPosition" class="headerlink" title="scrollToPosition"></a>scrollToPosition</h2><p><img src="http://7xq7yd.com1.z0.glb.clouddn.com/RecycleView-ScrollToPosition.gif" alt="recyclerView.scrollToPosition(position)"></p>
<p>使用： <code>recyclerView.scrollToPosition(position)</code></p>
<p><code>scrollToPosition(position)</code>这个方法的作用是定位到指定项，就是把你想显示的项显示出来，但是在屏幕的什么位置是不管的，只要那一项现在看得到了，那它就罢工了！ </p>
<h2 id="smoothScrollToPosition"><a href="#smoothScrollToPosition" class="headerlink" title="smoothScrollToPosition"></a>smoothScrollToPosition</h2><p><img src="http://7xq7yd.com1.z0.glb.clouddn.com/RecycleView-SmoothScriollToPosition.gif" alt="recyclerView.smoothScrollToPosition(position)"></p>
<p>使用： <code>recyclerView.smoothScrollToPosition(position)</code></p>
<p><code>smoothScrollToPosition(position)</code>和<code>scrollToPosition(position)</code>效果基本相似，也是把你想显示的项显示出来，只要那一项现在看得到了，那它就罢工了，不同的是smoothScrollToPosition是平滑到你想显示的项，而scrollToPosition是直接定位显示！</p>
<h2 id="scrollToPositionWithOffset"><a href="#scrollToPositionWithOffset" class="headerlink" title="scrollToPositionWithOffset"></a>scrollToPositionWithOffset</h2><p><img src="http://7xq7yd.com1.z0.glb.clouddn.com/RecycleView-ScrollToPositionWithOffset.gif" alt="recyclerView.smoothScrollToPosition(position)"></p>
<p>使用： <code>((LinearLayoutManager)recyclerView.getLayoutManager()).scrollToPositionWithOffset(position,0);</code></p>
<p>主角总是最后才登场，这种方式是定位到指定项如果该项可以置顶就将其置顶显示。比如:微信联系人的字母索引定位就是采用这种方式实现。</p>
<h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><p><a href="https://raw.githubusercontent.com/z-chu/RecyclerView-Scroll-Sample/master/app/app-release.apk" target="_blank" rel="external">apk下载</a></p>
<p><a href="https://github.com/z-chu/RecyclerView-Scroll-Sample" target="_blank" rel="external">Github</a></p>
<h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><p><a href="http://blog.csdn.net/tyzlmjj/article/details/49227601" title=" Android RecyclerView滚动定位" target="_blank" rel="external">Android RecyclerView滚动定位</a></p>
<p><a href="http://blog.csdn.net/a86261566/article/details/50906456" target="_blank" rel="external">RecyclerView调用smoothScrollToPosition() 控制滑动速度</a></p>
<p><a href="http://www.jianshu.com/p/b3edc873b42d" target="_blank" rel="external">RecyclerView使用技巧-自动滚动</a></p>
<p><a href="https://www.zhihu.com/question/31270461" target="_blank" rel="external">如何获取 RecyclerView 的滑动距离？</a></p>
<p><a href="http://blog.csdn.net/csdn_lqr/article/details/53859707" title="RecyclerView滚动到指定位置" target="_blank" rel="external"> RecyclerView滚动到指定位置</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;相信大家在项目中使用RecyclerView时，经常会遇到这样的需求：&lt;br&gt;将RecyclerView滑动到指定位置，或者检索RecyclerView的某一项（各个项的高度不确定），然后定位滚动这到一项，将它显示。&lt;/p&gt;
&lt;p&gt;下面就讲解4种RecyclerView定位滚动的方式及具体效果演示。&lt;/p&gt;
&lt;h2 id=&quot;scrollBy&quot;&gt;&lt;a href=&quot;#scrollBy&quot; class=&quot;headerlink&quot; title=&quot;scrollBy&quot;&gt;&lt;/a&gt;scrollBy&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://7xq7yd.com1.z0.glb.clouddn.com/RecycleView-ScrollBy.gif&quot; alt=&quot;recyclerView.scrollBy(x, y)&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用：&lt;code&gt;recyclerView.scrollBy(x, y)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;scrollBy(x, y)&lt;/code&gt;这个方法是自己去控制移动的距离，单位是像素,所以在使用&lt;code&gt;scrollBy(x, y)&lt;/code&gt;需要自己去计算移动的高度或宽度。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="RecycleView" scheme="http://yoursite.com/tags/RecycleView/"/>
    
  </entry>
  
  <entry>
    <title>浅谈设计模式之单例模式</title>
    <link href="http://yoursite.com/2017/02/09/singleton-pattern/"/>
    <id>http://yoursite.com/2017/02/09/singleton-pattern/</id>
    <published>2017-02-09T14:23:54.000Z</published>
    <updated>2017-02-09T14:33:25.022Z</updated>
    
    <content type="html"><![CDATA[<p>当我们有这样的需求:<strong>某一些类应该只存在一个实例</strong> 的时候,我们就可以用单例模式来应对.</p>
<p>单例模式是所有设计模式中最简单的一个,也是大部分人最早知道的一个设计模式.</p>
<p>但是即使是最简单的,也有很多可以推敲的细节,要做得对也不简单.</p>
<h2 id="经典的单例"><a href="#经典的单例" class="headerlink" title="经典的单例"></a>经典的单例</h2><p>相信大家一定写过这样类似的单例模式代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</div><div class="line">            instance = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单总结一下这样的写法:</p>
<ol>
<li>提供一个全局静态的getInstance方法,使得易于使用.</li>
<li>延迟Singleton的实例化,节省资源(所谓的懒汉式).</li>
<li>缺点是线程不安全.当多个线程同时进入<code>if (null == instance) {}</code>的时候就会创建多个实例.</li>
</ol>
<p>OK,接下来我们看来是要解决多线程不安全的问题了.<br><a id="more"></a></p>
<h2 id="多线程安全"><a href="#多线程安全" class="headerlink" title="多线程安全"></a>多线程安全</h2><p>这个时候可能有的人就说了,这个太简单了,加一个<code>synchronized</code>不就结了吗?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</div><div class="line">        instance = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>确实,增加<code>synchronized</code>之后能够迫使每个线程在进入这个方法之前,要先等别的线程离开该方法.也即避免了多个线程同时进入<code>getInstance</code>方法.</p>
<p>诚然这个能解决问题,但是我们知道<code>synchronized</code>是非常耗性能的.</p>
<p>更何况:<br>我们只需要在第一次执行这个方法的时候同步,也就是说当instance实例化后,我们不再需要同步了<br>而如果我们加了<code>synchronized</code>,那么实例化后的每次调用<code>getInstance</code>都是一种多余的消耗操作,是累赘</p>
<blockquote>
<p>当然,如果哪些额外的负担你能接受(比如用的很少),那么添加<code>synchronized</code>的方法也是可以接受的,毕竟这是最简单的方式.</p>
</blockquote>
<p>那么问题来了,如何改善?<br>如何确保单例,而又不影响性能?</p>
<h2 id="性能进阶"><a href="#性能进阶" class="headerlink" title="性能进阶"></a>性能进阶</h2><p>接下去介绍一种更优秀的,线程安全的单例写法—双重检查锁模式(double check locking pattern)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheck</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheck instance;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheck</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheck <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span>==instance)&#123; <span class="comment">//检查</span></div><div class="line">            <span class="keyword">synchronized</span> (DoubleCheck.class)&#123;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123; <span class="comment">//又检查一次</span></div><div class="line">                    instance = <span class="keyword">new</span> DoubleCheck();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里的instance用了<code>volatile</code>关键字来修饰,为什么呢?<br>因为执行<code>instance = new DoubleCheck()</code>做了很多事情:</p>
<ol>
<li>给instance分配内存</li>
<li>调用构造函数来初始化成员变量(可能会很久)</li>
<li>将ins对象指向分配的内存空间（执行完这步 ins才不为null）</li>
</ol>
<p>上面的操作并不是原子操作,而jvm也可能重排序指令,导致第二三两步的执行顺序可能会被打乱,当第3步先于第2步完成,那么会导致有线程拿到了初始化未完毕的<code>instance</code>,那么就会错误,而这里利用了<code>volatile</code>的禁止指令重排序优化特性,用来解决这个问题.</p>
<blockquote>
<p>注:<code>volatile</code> 在java 5 后才有效,原因是 Java 5 以前的 Java 内存模型是存在缺陷的,当然现在不需要担心这个啦!</p>
</blockquote>
<p>小结</p>
<p>双重检查非常适用于高并发,我们熟知的开源库<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a>,<a href="https://github.com/bumptech/glide" target="_blank" rel="external">Glide</a>等都是用的双重检查锁方式实现单例</p>
<p>不过它,写起来稍微复杂了些,有没有简单点的呢?<br>答案是:有!</p>
<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>直接上代码吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Early</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Early instance = <span class="keyword">new</span> Early();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Early <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>饿汉式的原理其实是<strong>基于classLoader机制</strong>来避免了多线程的同步问题</p>
<p>饿汉式与之前提到的懒汉式不同,它在我们调用getInstance之前就实例化了(在类加载的时候就实例化了),所以不是一个懒加载,这样就有几个缺点:</p>
<ol>
<li>延长了类加载时间</li>
<li>如果没用到这个类,就浪费了资源(加载了但是没用它)</li>
<li>不能传递参数(很显然适用的场景会减少)</li>
</ol>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类原理同上,另外虽然它看上去有点恶汉式,但是与之前的恶汉有点不同,它在类<code>Singleton</code>加载完毕后并没有实例化,而是当调用<code>getInstance</code>去加载Holder的时候才会实例化,静态内部类的方式把实例化延迟到了内部类的加载中去了!所以它比饿汉式更优秀!(偷偷告诉你<a href="https://book.douban.com/subject/1103015/" target="_blank" rel="external">《Effective Java》</a>中也推荐这个方式)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> Holder.INSTANCE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>最后介绍一种,也是我在<a href="https://book.douban.com/subject/1103015/" target="_blank" rel="external">《Effective Java》</a>中看到的,居然用枚举!!!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</div><div class="line">    INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看上去好牛逼，通过<code>Singleton.INSTANCE</code>来访问，这比调用getInstance()方法简单多了。这种方式是<a href="https://book.douban.com/subject/1103015/" target="_blank" rel="external">《Effective Java》</a>作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊。</p>
<p>默认枚举实例的创建是线程安全的，所以不需要担心线程安全的问题。但是在枚举中的其他任何方法的线程安全由程序员自己负责。还有防止上面的通过反射机制调用私用构造器。</p>
<p>这个版本基本上消除了绝大多数的问题。代码也非常简单，实在无法不用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单例模式（Singleton）会控制其实例对象的数量，从而确保访问对象的唯一性。</p>
<h4 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h4><ol>
<li>实例控制：单例模式防止其它对象对自己的实例化，确保所有的对象都访问一个实例。</li>
<li>伸缩性：因为由类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。</li>
</ol>
<h4 id="单例模式的缺点"><a href="#单例模式的缺点" class="headerlink" title="单例模式的缺点"></a>单例模式的缺点</h4><ol>
<li>系统开销。虽然这个系统开销看起来很小，但是每次引用这个类实例的时候都要进行实例是否存在的检查。这个问题可以通过静态实例来解决。</li>
<li>开发混淆。当使用一个单例模式的对象的时候（特别是定义在类库中的），开发人员必须要记住不能使用new关键字来实例化对象。因为开发者看不到在类库中的源代码，所以当他们发现不能实例化一个类的时候会很惊讶。</li>
<li>对象生命周期。单例模式没有提出对象的销毁。在提供内存管理的开发语言（比如，基于.NetFramework的语言）中，只有单例模式对象自己才能将对象实例销毁，因为只有它拥有对实例的引用。在各种开发语言中，比如C++，其它类可以销毁对象实例，但是这么做将导致单例类内部的指针指向不明。</li>
</ol>
<h4 id="单例适用性"><a href="#单例适用性" class="headerlink" title="单例适用性"></a>单例适用性</h4><p>使用Singleton模式有一个必要条件：在一个系统要求一个类只有一个实例时才应当使用单例模式。反之，如果一个类可以有几个实例共存，就不要使用单例模式。</p>
<p>不要使用单例模式存取全局变量。这违背了单例模式的用意，最好放到对应类的静态成员中。</p>
<p>不要将数据库连接做成单例，因为一个系统可能会与数据库有多个连接，并且在有连接池的情况下，应当尽可能及时释放连接。Singleton模式由于使用静态成员存储类实例，所以可能会造成资源无法及时释放，带来问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们有这样的需求:&lt;strong&gt;某一些类应该只存在一个实例&lt;/strong&gt; 的时候,我们就可以用单例模式来应对.&lt;/p&gt;
&lt;p&gt;单例模式是所有设计模式中最简单的一个,也是大部分人最早知道的一个设计模式.&lt;/p&gt;
&lt;p&gt;但是即使是最简单的,也有很多可以推敲的细节,要做得对也不简单.&lt;/p&gt;
&lt;h2 id=&quot;经典的单例&quot;&gt;&lt;a href=&quot;#经典的单例&quot; class=&quot;headerlink&quot; title=&quot;经典的单例&quot;&gt;&lt;/a&gt;经典的单例&lt;/h2&gt;&lt;p&gt;相信大家一定写过这样类似的单例模式代码:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton instance;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; == instance) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;简单总结一下这样的写法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提供一个全局静态的getInstance方法,使得易于使用.&lt;/li&gt;
&lt;li&gt;延迟Singleton的实例化,节省资源(所谓的懒汉式).&lt;/li&gt;
&lt;li&gt;缺点是线程不安全.当多个线程同时进入&lt;code&gt;if (null == instance) {}&lt;/code&gt;的时候就会创建多个实例.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;OK,接下来我们看来是要解决多线程不安全的问题了.&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式概览</title>
    <link href="http://yoursite.com/2017/02/08/Design-patterns-2/"/>
    <id>http://yoursite.com/2017/02/08/Design-patterns-2/</id>
    <published>2017-02-08T15:10:41.000Z</published>
    <updated>2017-02-08T15:22:05.700Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><ul>
<li>某类特定问题的代码设计解决方案</li>
<li>是一套代码设计的经验总结<blockquote>
<p>设计模式，其实只是前人针对某类问题的代码设计经验而已，并没有很高大上</p>
</blockquote>
</li>
</ul>
<h2 id="2-作用"><a href="#2-作用" class="headerlink" title="2.作用"></a>2.作用</h2><ul>
<li>提高代码复用率，降低开发成本和周期</li>
<li>提高代码可维护性、可拓展性</li>
<li>使代码更加优雅</li>
<li>让代码更容易被他人理解</li>
</ul>
<h2 id="3-七大设计原则"><a href="#3-七大设计原则" class="headerlink" title="3.七大设计原则"></a>3.七大设计原则</h2><p><img src="http://7xq7yd.com1.z0.glb.clouddn.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.PNG" alt="设计模式总览图"></p>
<a id="more"></a>
<h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><p>一个实体（类、函数、模块等）应该对外扩展开放，对内修改关闭</p>
<p>简单的说就是，别人可以基于你的代码进行拓展编写，但却不能修改你的代码。<br>反过来说就是，你在写代码时就要考虑到：怎么让别人可以不修改你的代码，就能对你的代码进行扩展。</p>
<p>开闭原则是面向对象设计中“可复用设计”的基石，是面向对象设计中最重要的原则之一，其他原则都可以看作是开闭原则的实现方法。</p>
<blockquote>
<ol>
<li>即每次发生变化时，要通过添加新的代码来增强现有类型的行为，而不是修改原有的代码。</li>
<li>符合开放封闭原则的最好方式是提供一个固有的接口，然后让所有可能发生变化的类实现该接口，让固定的接口与相关对象进行交互。</li>
</ol>
</blockquote>
<h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p>一个类应该只能有一个引起它变化的原因。</p>
<blockquote>
<p>一个类，只有一个引起它变化的原因。应该只有一个职责。每一个职责都是变化的一个轴线，如果一个类有一个以上的职责，这些职责就耦合在了一起。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。例如：要实现逻辑和界面的分离。</p>
</blockquote>
<h4 id="里氏代替原则"><a href="#里氏代替原则" class="headerlink" title="里氏代替原则"></a>里氏代替原则</h4><p>任何基类可以出现的地方，子类一定可以出现。<br>子类可以扩展父类的功能，但不能改变父类原有的功能。</p>
<blockquote>
<ol>
<li>在软件开发过程中，子类替换父类后，程序的表现行为是一样的。</li>
<li>只有当子类替换掉父类后软件的功能不受影响时，父类才能真正地被复用，而子类也可以在父类的基础上添加新的行为。</li>
</ol>
</blockquote>
<h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><p>程序要依赖于抽象接口，不要依赖于具体实现。简单的说就面向抽象进行编程，不要面向实现进行编程，这样就降低了客户与实现模块间的耦合。</p>
<blockquote>
<ol>
<li>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。</li>
<li>抽象不应该依赖于具体，具体应该依赖于抽象。</li>
</ol>
</blockquote>
<h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><p>程序不应该依赖它不需要的接口。一个类对另一个类的依赖应该建立在最小的接口上。</p>
<blockquote>
<p>使用多个专门的接口比使用单一的总接口要好。<br>一个类对另外一个类的依赖性应当是建立在最小的接口上的。<br>一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。</p>
</blockquote>
<h4 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h4><p>在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分。</p>
<blockquote>
<p>新对象通过向这些对象的委派达到复用已用功能的目的。简单地说，就是要尽量使用合成/聚合，尽量不要使用继承。</p>
</blockquote>
<h4 id="最少知识原则（迪米特法则）"><a href="#最少知识原则（迪米特法则）" class="headerlink" title="最少知识原则（迪米特法则）"></a>最少知识原则（迪米特法则）</h4><p>一个模块或对象应尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立，这样当一个模块修改时，影响的模块就会越少，扩展起来更加容易。</p>
<blockquote>
<p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。<br>关于迪米特法则的其他描述：只与你直接的朋友们通信；不要跟“陌生人”说话。</p>
</blockquote>
<h2 id="4-七大设计原则"><a href="#4-七大设计原则" class="headerlink" title="4.七大设计原则"></a>4.七大设计原则</h2><p>分3大类，共23种设计模式.</p>
<p><img src="http://7xq7yd.com1.z0.glb.clouddn.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB-23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20.png" alt="设计模式总览图"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;headerlink&quot; title=&quot;1.定义&quot;&gt;&lt;/a&gt;1.定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;某类特定问题的代码设计解决方案&lt;/li&gt;
&lt;li&gt;是一套代码设计的经验总结&lt;blockquote&gt;
&lt;p&gt;设计模式，其实只是前人针对某类问题的代码设计经验而已，并没有很高大上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-作用&quot;&gt;&lt;a href=&quot;#2-作用&quot; class=&quot;headerlink&quot; title=&quot;2.作用&quot;&gt;&lt;/a&gt;2.作用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;提高代码复用率，降低开发成本和周期&lt;/li&gt;
&lt;li&gt;提高代码可维护性、可拓展性&lt;/li&gt;
&lt;li&gt;使代码更加优雅&lt;/li&gt;
&lt;li&gt;让代码更容易被他人理解&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3-七大设计原则&quot;&gt;&lt;a href=&quot;#3-七大设计原则&quot; class=&quot;headerlink&quot; title=&quot;3.七大设计原则&quot;&gt;&lt;/a&gt;3.七大设计原则&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://7xq7yd.com1.z0.glb.clouddn.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.PNG&quot; alt=&quot;设计模式总览图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面向对象基础</title>
    <link href="http://yoursite.com/2017/02/07/Design-patterns-1/"/>
    <id>http://yoursite.com/2017/02/07/Design-patterns-1/</id>
    <published>2017-02-07T14:15:17.000Z</published>
    <updated>2017-02-07T14:36:13.900Z</updated>
    
    <content type="html"><![CDATA[<p>一个面向对象的程序（ OOP ）实际上就是一个相对去中心化、模块化的程序。<br>对于一个 OOP 来说，它的一个 “ 碎片 “ ，就是一个独立成立、保持自身完整性的单元；它可以和其他的 OOP” 碎片 “ 整合在一起形成一个可分解的指令结构。<br>“ 对象 “ 限制了程序漏洞所能造成的损害，有效地对功能实行了隔离，把每个功能都限制在一个可掌控的单元内，这样一来，即使一个对象崩溃了，程序的其他部分也能够继续运转。<br>程序员可以把这个坏掉的单元换掉，就好像我们可以给一个汽车换刹车片一样。<br>再比如：<br>我们做的 app ，它有许多的功能，每一个功能它对应一个模块。我们通过一个一个实现再把这些模块堆起来，通过我们的接口、方法、回调等把它们组合起来，最后形成我们的面向对象程序，也就是最后生成了我们的 app .<br><strong>模块自身应该是单一的、高内聚的，模块与模块之间应该是低耦合的</strong></p>
<h1 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h1><p>JAVA面向对象最重要的特征就是：封装，继承，多态(所谓的三大特征)。<br>以下就个人体会来简单讲一下.<br><a id="more"></a></p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。该逻辑单元负责将所描述的属性隐藏起来，外界对客体内部属性的所有访问只能通过提供的用户接口实现。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>封装就是隐藏实现细节。使用者只需要关注怎么用，而不需要关注内部是怎么实现的。实现细节可以随时修改，而不影响使用者。</li>
<li>抽取可复用的逻辑单元,统一处理,提高效率。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>过度封装会不利于程序扩展，可变性降低.</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力.<br>Java继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>代码重用：子类继承父类后拥有父类的属性成员,可以很好的复用已有的类,不需要再重复写方法属性.</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>如果继承很重,那么子类不管要不要，有没有用，都会拥有父类的所有东西，影响子类性能造成代码冗余.</li>
<li>继承可能破坏封装：因为子类和父类之间可能存在着实现细节的依赖.<br>子类在继承父类的时候，往往不得不关注父类的实现细节，而父类在修改其内部实现的时候，<br>如果不考虑子类，也往往会影响到子类.</li>
</ol>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态的作用，就是把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化.</p>
<p>多态在设计模式中扮演着非常非常重要的角色.<br>策略模式,里氏替换原则等就是多态的特性的最好阐述.</p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ol>
<li>消除类型之间的耦合关系.</li>
<li>可实现动态绑定,增加可扩展性.</li>
</ol>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>会使代码可读性变差，在定位代码的时候比较麻烦,需要去寻找具体的实现类。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个面向对象的程序（ OOP ）实际上就是一个相对去中心化、模块化的程序。&lt;br&gt;对于一个 OOP 来说，它的一个 “ 碎片 “ ，就是一个独立成立、保持自身完整性的单元；它可以和其他的 OOP” 碎片 “ 整合在一起形成一个可分解的指令结构。&lt;br&gt;“ 对象 “ 限制了程序漏洞所能造成的损害，有效地对功能实行了隔离，把每个功能都限制在一个可掌控的单元内，这样一来，即使一个对象崩溃了，程序的其他部分也能够继续运转。&lt;br&gt;程序员可以把这个坏掉的单元换掉，就好像我们可以给一个汽车换刹车片一样。&lt;br&gt;再比如：&lt;br&gt;我们做的 app ，它有许多的功能，每一个功能它对应一个模块。我们通过一个一个实现再把这些模块堆起来，通过我们的接口、方法、回调等把它们组合起来，最后形成我们的面向对象程序，也就是最后生成了我们的 app .&lt;br&gt;&lt;strong&gt;模块自身应该是单一的、高内聚的，模块与模块之间应该是低耦合的&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;面向对象三大特征&quot;&gt;&lt;a href=&quot;#面向对象三大特征&quot; class=&quot;headerlink&quot; title=&quot;面向对象三大特征&quot;&gt;&lt;/a&gt;面向对象三大特征&lt;/h1&gt;&lt;p&gt;JAVA面向对象最重要的特征就是：封装，继承，多态(所谓的三大特征)。&lt;br&gt;以下就个人体会来简单讲一下.&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>开闭原则</title>
    <link href="http://yoursite.com/2017/01/23/OpenClosedPrinciple/"/>
    <id>http://yoursite.com/2017/01/23/OpenClosedPrinciple/</id>
    <published>2017-01-23T14:38:41.000Z</published>
    <updated>2017-01-23T14:41:35.046Z</updated>
    
    <content type="html"><![CDATA[<p>面向扩展开放，面向修改关闭。简单的说就是，别人可以基于你的代码进行拓展编写，但却不能修改你的代码</p>
<p>开闭原则（OCP）是面向对象设计中“可复用设计”的基石，是面向对象设计七大原则之一，也是面向对象设计中最重要的原则之一，实际上<a href="http://baike.baidu.com/view/1688346.htm" target="_blank" rel="external">里氏替换原则</a>（LSP）、<a href="http://baike.baidu.com/view/1996652.htm" target="_blank" rel="external">依赖倒转原则</a>（DIP）、<a href="http://baike.baidu.com/view/1638378.htm" target="_blank" rel="external">接口隔离原则</a>（ISP）以及<a href="http://baike.baidu.com/view/262290.htm" target="_blank" rel="external">抽象类</a>（Abstract Class）、<a href="http://baike.baidu.com/view/159864.htm" target="_blank" rel="external">接口</a>(Interface)等等，都可以看作是开闭原则的实现方法。</p>
<h2 id="面向扩展开放，面向修改关闭"><a href="#面向扩展开放，面向修改关闭" class="headerlink" title="面向扩展开放，面向修改关闭"></a>面向扩展开放，面向修改关闭</h2><ol>
<li><p>对于扩展是开放的（Open for extension）。这意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。也就是说，我们可以改变模块的功能。</p>
</li>
<li><p>对于修改是关闭的（Closed for modification）。对模块行为进行扩展时，不必改动模块的源代码。相对的在设计时就应考虑到，不需要改动模块的源代码，就可以对模块进行扩展。</p>
</li>
</ol>
<h2 id="开闭原则的相对性"><a href="#开闭原则的相对性" class="headerlink" title="开闭原则的相对性"></a>开闭原则的相对性</h2><p>软件系统的构建是一个需要不断重构的过程，在这个过程中，模块的功能抽象，模块与模块间的关系，都不会从一开始就非常清晰明了，所以构建100%满足开闭原则的软件系统是相当困难的，这就是开闭原则的相对性。但在设计过程中，通过对模块功能的抽象（接口定义），模块之间的关系的抽象（通过接口调用），抽象与实现的分离（面向接口的程序设计）等，可以尽量接近满足开闭原则。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面向扩展开放，面向修改关闭。简单的说就是，别人可以基于你的代码进行拓展编写，但却不能修改你的代码&lt;/p&gt;
&lt;p&gt;开闭原则（OCP）是面向对象设计中“可复用设计”的基石，是面向对象设计七大原则之一，也是面向对象设计中最重要的原则之一，实际上&lt;a href=&quot;http://ba
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>我对MVC和MVP的一些理解</title>
    <link href="http://yoursite.com/2017/01/21/architecture1/"/>
    <id>http://yoursite.com/2017/01/21/architecture1/</id>
    <published>2017-01-21T08:20:24.000Z</published>
    <updated>2017-01-21T10:33:59.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC是软件架构中最常见的一种框架,简单来说就是通过controller的控制去操作model层的数据，并且返回给view层展示.<br>比如当用户出发事件的时候，view层会发送指令到controller层，接着controller去通知model层更新数据，model层更新完数据以后直接显示在view层上，这就是MVC的工作原理。</p>
<p>那具体到Android上是怎么样一个情况呢？<br>对于原生的Android项目来说，layout.xml里面的xml文件就对应于MVC的view层，<br>里面都是一些view的布局代码，而各种java bean，<br>还有一些数据相关的类就对应于model层，至于controller层嘛，当然就是各种activity咯。</p>
<p>举个例子:<br>比如你的界面有一个按钮，按下这个按钮去网络上下载一个文件.<br>这个按钮是view层的，是使用xml来写的.这个下载文件的工作,你可以写一个专门的下载器,这个就是model层.</p>
<p>那怎么连接这两层呢？<br>当然是在activity通过给这个按钮设置点击事件的监听,在响应点击事件时去启动这个下载器，这就对应于controller层.</p>
<p>问题就在于xml作为view层，控制能力实在太弱了，你想去动态的改变一个页面的背景，或者动态的隐藏/显示一个按钮，<br>必须要获得这个view 对象去操控,这些都没办法在xml中做，只能把代码写在activity中，造成了activity既是controller层，又是view层的这样一个窘境。<br>如果是一个逻辑很复杂的页面，activity或者fragment是不是动辄上千行呢？这样不仅写起来麻烦，维护起来更是噩梦。<br><a id="more"></a><br>MVC还有一个重要的缺陷，view层和model层是相互可知的，这意味着两层之间存在耦合.</p>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP作为MVC的演化，解决了MVC不少的缺点.</p>
<p>对于Android来说，MVP的model层相对于MVC是一样的,而activity和fragment不再是controller层，而是纯粹的view层，所有关于用户事件的转发全部交由presenter层处理。</p>
<p>与MVC最明显的差别就是view层和model层不再相互可知，完全的解耦，MVC中View会直接从Model中读取数据而不是通过 Controller。<br>取而代之的presenter层充当了桥梁的作用，用于操作view层发出的事件传递到presenter层中，presenter层去操作model层，并且将数据返回给view层，整个过程中view层和model层完全没有联系。</p>
<p>看到这里大家可能会问，虽然view层和model层解耦了，但是view层和presenter层不是耦合在一起了吗？<br>其实不是的，对于view层和presenter层的通信，我们是可以通过接口实现的，具体的意思就是说我们的activity，<br>fragment可以去实现实现定义好的接口，而在对应的presenter中通过接口调用方法。<br>不仅如此，我们还可以编写测试用的View，模拟用户的各种操作，从而实现对Presenter的测试。</p>
<p>这就解决了MVC模式中测试，维护难的问题。<br>具体来说，如果你需要测试一个http请求是否顺利，你不需要写一个activity，只需要写一个java类，实现对应的接口，presenter获取了数据自然会调用相应的方法，相应的，你也可以自己在presenter中模仿数据，<br>分发给view层，用来测试布局是否正确。</p>
<p>MVP的问题在于，由于我们使用了接口的方式去连接view层和presenter层，这样就导致了一个问题，如果你有一个逻辑很复杂的页面，你的接口会有很多，十几二十个都不足为奇。想象一个app中有很多个这样复杂的页面，维护接口的成本就会非常的大。</p>
<p>这个问题的解决方案就是你得根据自己的业务逻辑去斟酌着写接口。你可以定义一些基类接口，把一些公共的逻辑，比如网络请求成功失败，toast等等放在里面，之后你再定义新的接口的时候可以继承自那些基类，这样会好不少。</p>
<h3 id="MVP的优点"><a href="#MVP的优点" class="headerlink" title="MVP的优点"></a>MVP的优点</h3><ol>
<li>降低耦合度，隐藏数据，Activity中代码更简洁</li>
<li>模块职责划分明显</li>
<li>方便测试驱动开发</li>
<li>代码复用度较高</li>
<li>代码灵活性</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从MVC到MVP的一个转变，就是减少了Activity的职责，减轻了它的负担，简化了Activity中的代码和一些操作，将逻辑代码提取到了Presenter中进行处理，降低了其耦合度。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MVC&quot;&gt;&lt;a href=&quot;#MVC&quot; class=&quot;headerlink&quot; title=&quot;MVC&quot;&gt;&lt;/a&gt;MVC&lt;/h2&gt;&lt;p&gt;MVC是软件架构中最常见的一种框架,简单来说就是通过controller的控制去操作model层的数据，并且返回给view层展示.&lt;br&gt;比如当用户出发事件的时候，view层会发送指令到controller层，接着controller去通知model层更新数据，model层更新完数据以后直接显示在view层上，这就是MVC的工作原理。&lt;/p&gt;
&lt;p&gt;那具体到Android上是怎么样一个情况呢？&lt;br&gt;对于原生的Android项目来说，layout.xml里面的xml文件就对应于MVC的view层，&lt;br&gt;里面都是一些view的布局代码，而各种java bean，&lt;br&gt;还有一些数据相关的类就对应于model层，至于controller层嘛，当然就是各种activity咯。&lt;/p&gt;
&lt;p&gt;举个例子:&lt;br&gt;比如你的界面有一个按钮，按下这个按钮去网络上下载一个文件.&lt;br&gt;这个按钮是view层的，是使用xml来写的.这个下载文件的工作,你可以写一个专门的下载器,这个就是model层.&lt;/p&gt;
&lt;p&gt;那怎么连接这两层呢？&lt;br&gt;当然是在activity通过给这个按钮设置点击事件的监听,在响应点击事件时去启动这个下载器，这就对应于controller层.&lt;/p&gt;
&lt;p&gt;问题就在于xml作为view层，控制能力实在太弱了，你想去动态的改变一个页面的背景，或者动态的隐藏/显示一个按钮，&lt;br&gt;必须要获得这个view 对象去操控,这些都没办法在xml中做，只能把代码写在activity中，造成了activity既是controller层，又是view层的这样一个窘境。&lt;br&gt;如果是一个逻辑很复杂的页面，activity或者fragment是不是动辄上千行呢？这样不仅写起来麻烦，维护起来更是噩梦。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="http://yoursite.com/2017/01/21/prototype-pattern/"/>
    <id>http://yoursite.com/2017/01/21/prototype-pattern/</id>
    <published>2017-01-21T07:50:24.000Z</published>
    <updated>2017-01-23T14:41:19.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式的定义"><a href="#模式的定义" class="headerlink" title="模式的定义"></a>模式的定义</h2><p>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。</p>
<h2 id="模式的使用场景"><a href="#模式的使用场景" class="headerlink" title="模式的使用场景"></a>模式的使用场景</h2><ol>
<li>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等，通过原型拷贝避免这些消耗；</li>
<li>通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式；</li>
<li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝。</li>
</ol>
<h2 id="Android源码中的模式实现"><a href="#Android源码中的模式实现" class="headerlink" title="Android源码中的模式实现"></a>Android源码中的模式实现</h2><p>Intent中使用了原型模式</p>
<pre><code class="java">Uri uri = Uri.parse(<span class="string">"smsto:0800000123"</span>);    
Intent shareIntent = <span class="keyword">new</span> Intent(Intent.ACTION_SENDTO, uri);    
shareIntent.putExtra(<span class="string">"sms_body"</span>, <span class="string">"The SMS text"</span>);    

Intent intent = (Intent)shareIntent.clone() ;
startActivity(intent);
</code></pre>
<h2 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>原型模式是在内存二进制流的拷贝，要比直接 new 一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的，在实际开发当中应该注意这个潜在的问题。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;模式的定义&quot;&gt;&lt;a href=&quot;#模式的定义&quot; class=&quot;headerlink&quot; title=&quot;模式的定义&quot;&gt;&lt;/a&gt;模式的定义&lt;/h2&gt;&lt;p&gt;用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。&lt;/p&gt;
&lt;h2 id=&quot;模式的使用场景&quot;&gt;&lt;a hr
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Android面试之性能优化</title>
    <link href="http://yoursite.com/2017/01/21/Android-interview3/"/>
    <id>http://yoursite.com/2017/01/21/Android-interview3/</id>
    <published>2017-01-21T06:17:17.000Z</published>
    <updated>2017-01-21T10:33:38.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><ol>
<li>界面不流程，如何去debug调试View，来定位卡顿问题？</li>
<li>如何解决卡顿问题？</li>
<li>xml编写和View写法是否合理？</li>
<li>移除不必要的背景图<ul>
<li>window默认背景图</li>
<li>ListView设置背景后，item又设置了背景图</li>
<li>多层嵌套，多次设置背景图</li>
</ul>
</li>
<li>优化布局避免空间View树过高，空间重叠</li>
<li>自定义View的时候使用clipRect裁剪出需要绘制的区域绘制，已减少其他区域的绘制。</li>
</ol>
<p>　可以通过Android SDK提供的Hierarchy View可量化的子View的总是和测量（measure）、布局（layout）、绘制（draw）所消耗的时间，以及View层级树的高度</p>
<p>　首先要明白的是UI的绘制流程：measure-layout-draw，measure与layout都需要for loop所有的子控件，汇集起来才能完成绘制，布局。所以子控件越多，所消耗的时间越长(inflate，layout_weight，relative，多层嵌套等)，减少不必要的子控件或层级，是相当有必要的。你可以通过merge,viewstub这些标签来减少层级嵌套。如果你的空间观念没那么好，可以用HierarchyViewer工具来检查。<br><a id="more"></a></p>
<h1 id="Mesure过程"><a href="#Mesure过程" class="headerlink" title="Mesure过程"></a>Mesure过程</h1><ul>
<li>设置本View视图的最终大小</li>
<li>如果该View对象是个ViewGroup类型，需要重写该<code>onMeasure()</code>方法，对其子视图进行遍历的<code>measure()</code>过程。</li>
<li><code>measureChilren()</code>,内部使用一个for循环对子视图进行遍历，分别调用子视图的measure()方法</li>
<li><code>measureChlid()</code>，为指定的子视图measure，会被measureChildren调用</li>
<li><code>measureChildWithMargins()</code>,为指定子视图考虑了margin和padding的measure。</li>
</ul>
<h1 id="Layout过程"><a href="#Layout过程" class="headerlink" title="Layout过程"></a>Layout过程</h1><ol>
<li>layout方法会设置该View视图位于父视图的坐标轴，即mLeft,mTop,mRight，mBottom(调用<code>setFrame()</code>函数去实现）</li>
<li>接下来回调<code>onLayout()</code>方法（如果该View是ViewGroup对象，需要实现该方法，对每个子视图进行布局）</li>
<li>如果该View是个ViewGroup类型，需要遍历每个子视图的childView，调用该子视图的layout()方法去设置它的坐标值</li>
</ol>
<h1 id="帧率"><a href="#帧率" class="headerlink" title="帧率"></a>帧率</h1><p>　在安卓中界面要看起来流畅，那么它的帧率是60，也就是说在1秒钟之内它会刷新60次，那么每次刷新的耗时也就是1000ms除了60，等于16.67ms.<br>　那么如果视图的刷新时间在16ms之内完成了，我们用起来就会觉得很流畅，那么假如因为某种原因，一个刷新过程没有在16ms之内完成，那么就会出现掉帧现象，也就是卡顿了。那么为了不出现这种掉帧现象，让用户用起来更流程，就需要尽量让一个绘制过程在16ms只能完成。<br>　这也就是性能优化所要最终完成的目标。Measure+Layout+Draw&lt;=16ms.<br>　那么我们就只要看measure、layout、draw都干了那些事情，有哪些点是可以优化的，只要逐个的解决这些优化点，也就完成了一系列的View优化工作。</p>
<h1 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h1><h3 id="从内优化（从View本身）"><a href="#从内优化（从View本身）" class="headerlink" title="从内优化（从View本身）"></a>从内优化（从View本身）</h3><ul>
<li>尽可能少的使用margin,padding<br>因为在测量绘制的过程中，会单独对已经设置过margin和padding的View进行另外多一步的操作，所有这个时候可以采用在父View中设置margin和padding来代替在子View中进行分别设置</li>
<li>减少View层级<br>这3个过程都涉及到循环遍历子View的过程，所有减少View的层级可以很好的加快循环遍历的过程</li>
<li>去除不必要的背景</li>
<li>去除不必要的scrollbar和不需要的效果</li>
<li>慎用渐变</li>
</ul>
<h3 id="从外优化"><a href="#从外优化" class="headerlink" title="从外优化"></a>从外优化</h3><ul>
<li>布局嵌套过于复杂<br>这个会直接导致View的层级变多，然后测量绘制的效率变差</li>
<li>View的过度绘制</li>
<li>View的频繁重新渲染</li>
<li><p>UI线程中进行耗时操作</p>
<p>在Android4.0其实是不允许ui线程中做网络操作了，那假如说你不小心做了写IO操作，而且他们又比较耗时，有可能会导致UI线程卡顿。View绘制阻塞</p>
</li>
<li><p>冗余资源及错误逻辑导致加载和执行缓慢（其实就代码写的烂）<br>比如你在<code>getView()</code>里去for循环，for循环里又for循环，又去声明变量之类的，都会导致代码的执行效率很差</p>
</li>
<li>频繁触发GC,导致渲染受阻<br>GC线程优先级高于UI线程，所有如果内存管理不够合理的话频繁的触发了GC,就会导致UI线程的受阻</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;性能优化&quot;&gt;&lt;a href=&quot;#性能优化&quot; class=&quot;headerlink&quot; title=&quot;性能优化&quot;&gt;&lt;/a&gt;性能优化&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;界面不流程，如何去debug调试View，来定位卡顿问题？&lt;/li&gt;
&lt;li&gt;如何解决卡顿问题？&lt;/li&gt;
&lt;li&gt;xml编写和View写法是否合理？&lt;/li&gt;
&lt;li&gt;移除不必要的背景图&lt;ul&gt;
&lt;li&gt;window默认背景图&lt;/li&gt;
&lt;li&gt;ListView设置背景后，item又设置了背景图&lt;/li&gt;
&lt;li&gt;多层嵌套，多次设置背景图&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优化布局避免空间View树过高，空间重叠&lt;/li&gt;
&lt;li&gt;自定义View的时候使用clipRect裁剪出需要绘制的区域绘制，已减少其他区域的绘制。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　可以通过Android SDK提供的Hierarchy View可量化的子View的总是和测量（measure）、布局（layout）、绘制（draw）所消耗的时间，以及View层级树的高度&lt;/p&gt;
&lt;p&gt;　首先要明白的是UI的绘制流程：measure-layout-draw，measure与layout都需要for loop所有的子控件，汇集起来才能完成绘制，布局。所以子控件越多，所消耗的时间越长(inflate，layout_weight，relative，多层嵌套等)，减少不必要的子控件或层级，是相当有必要的。你可以通过merge,viewstub这些标签来减少层级嵌套。如果你的空间观念没那么好，可以用HierarchyViewer工具来检查。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android面试之网络</title>
    <link href="http://yoursite.com/2017/01/21/Android-interview2/"/>
    <id>http://yoursite.com/2017/01/21/Android-interview2/</id>
    <published>2017-01-21T06:15:17.000Z</published>
    <updated>2017-01-21T10:46:38.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP、HTTP、Socket的区别"><a href="#TCP-IP、HTTP、Socket的区别" class="headerlink" title="TCP/IP、HTTP、Socket的区别"></a>TCP/IP、HTTP、Socket的区别</h1><p>网络由下往上分为：</p>
<p>物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p>
<p>我们知道IP协议对应网络层，TCP协议对应于传输层，而HTTP协议对应于应用层。</p>
<p>三者从本质上来说没有可比性，</p>
<p>Socket则是对TCP/IP协议的封装和应用(程序员层面上)。</p>
<p>也可以说，TCP/IP协议是传输层协议，主要解决数据如何在网络中传输，</p>
<p>而HTTP是应用层协议，主要解决如何包装数据。</p>
<p>关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：<br><a id="more"></a><br><strong>我们在传输数据时，可以只使用(传输层)TCP/IP协议。但那样的话，没有了应用层，便无法识别数据内容。</strong></p>
<p><strong>如果想要是传输的数据有意义，则必须使用到应用层协议。</strong></p>
<p><strong>应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。</strong></p>
<p><strong>web使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。</strong></p>
<p>而我们平时说的最多的Socket是什么呢，实际上Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API）。</p>
<p>通过Socket,我们才能使用TCP/IP协议。</p>
<p>实际上，Socket跟TCP/IP协议没有必然的联系。</p>
<p>SoCket编程接口在设计的时候，级希望也能适应其他的网络协议。</p>
<p>所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，</p>
<p>从而形成了我们知道的一些最基本的函数接口，比如create、listen、connect、accept、send、read和write等等。</p>
<p>网络有一段关于socket和TCP/IP协议关系的说法比较容易理解：</p>
<p><strong>TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还有提供对外的操作接口。</strong></p>
<p><strong>这个就像操作系统会提供标准的编程接口，比如win32编程接口一样，</strong></p>
<p><strong>TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。</strong></p>
<p>CSDN上有个比较现象的描述：<strong>HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。</strong></p>
<p>实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。</p>
<h1 id="什么是TCP连接的三次握手"><a href="#什么是TCP连接的三次握手" class="headerlink" title="什么是TCP连接的三次握手"></a>什么是TCP连接的三次握手</h1><p>第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k）,即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1),此包发送完毕，客户端和服务器进入ESTABLISHED（确认连接）状态，完成三次握手。</p>
<p>握手过程中传送的包含数据，三次握手完成后，客户端和服务器才正式开始传送数据。</p>
<p>理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP-IP、HTTP、Socket的区别&quot;&gt;&lt;a href=&quot;#TCP-IP、HTTP、Socket的区别&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP、HTTP、Socket的区别&quot;&gt;&lt;/a&gt;TCP/IP、HTTP、Socket的区别&lt;/h1&gt;&lt;p&gt;网络由下往上分为：&lt;/p&gt;
&lt;p&gt;物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。&lt;/p&gt;
&lt;p&gt;我们知道IP协议对应网络层，TCP协议对应于传输层，而HTTP协议对应于应用层。&lt;/p&gt;
&lt;p&gt;三者从本质上来说没有可比性，&lt;/p&gt;
&lt;p&gt;Socket则是对TCP/IP协议的封装和应用(程序员层面上)。&lt;/p&gt;
&lt;p&gt;也可以说，TCP/IP协议是传输层协议，主要解决数据如何在网络中传输，&lt;/p&gt;
&lt;p&gt;而HTTP是应用层协议，主要解决如何包装数据。&lt;/p&gt;
&lt;p&gt;关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android面试之java基础</title>
    <link href="http://yoursite.com/2017/01/21/Android-interview1/"/>
    <id>http://yoursite.com/2017/01/21/Android-interview1/</id>
    <published>2017-01-21T06:14:17.000Z</published>
    <updated>2017-01-21T10:52:47.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>　一个面向对象的程序（OOP）实际上就是一个相对去中心化、模块化的程序。</p>
<p>　对于一个OOP来说，它的一个”碎片”，就是一个独立成立、保持自身完整性的单元；它可以和其他的OOP”碎片”整合在一起形成一个可分解的指令结构。</p>
<p>　“对象”限制了程序漏洞所能造成的损害，有效地对功能实行了隔离，把每个功能都限制在一个可掌控的单元内，这样一来，即使一个对象崩溃了，程序的其他部分也能够继续运转。<br>程序员可以把这个坏掉的单元换掉，就好像我们可以给一个汽车换刹车片一样。<br>软件的销售商可以购买或者销售各种事先编制好的”对象”库给其他的软件研发人员，后者则可以基于这些库里的对象快速地组装起大型软件，而不用再像以前那样重新一行一行的编写新的代码。<br>而到了要为这种大型软件升级的时候，你所要做的就是升级旧的对象或者加入新的对象。</p>
<p>　再比如：我们做的app，它有许多的功能，每一个功能它对应一个模块。我们通过一个一个实现再把这些模块堆起来，通过我们的接口、方法、回调等把它们组合起来，最后形成我们的面向对象程序，也就是最后生成了我们的app。</p>
<p>　<strong>模块自身应该是单一的、高内聚的，模块与模块之间应该是低耦合的</strong><br><a id="more"></a></p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>　Java 1.5发行版本中增加了<a href="http://baike.baidu.com/link?url=1-VXaHvjPzn-1gMNiAipJJGyv6E7HAL0emZ-GwIOIzXwMCHGSxG8Vk27xGJfaDn2Svd2iMdd24RO9bAcBBAxrfLyoqGYOYn0INkg35Ii2PW" target="_blank" rel="external">泛型(Generic)</a>。<br>　在没有泛型之前，从集合中读取到的每个对象都必须进行转换。<br>如果有人不小心插入了类型错误的对象，在编译时是无法察觉的，在运行时的转换处理就会出错。<br>有了泛型之后，可以告诉编译起每个集合中接受哪些对象类型。编译器自动地为你的插入进行转化，并在编译是告知是否插入了类型错误的对象。<br>这样可以使程序既更加安全，又更加清楚。</p>
<p>　每个泛型都定义一个原生态类型,即不带任何实际类型参数的泛型名称。例如，与List<e>相对应的原生态类型是List。原生态类型就像从类型声明中删除了所有泛型信息一样。</e></p>
<p>　请不要在新代码中使用原生类型，<strong>如果使用原生态类型，就失掉了泛型在安全性和表述性方面的所有优势。</strong></p>
<h2 id="sleep-和wait-的区别"><a href="#sleep-和wait-的区别" class="headerlink" title="sleep()和wait()的区别"></a>sleep()和wait()的区别</h2><p><code>sleep()</code>方法和<code>wait()</code>方法都成产生让当前运行的线程停止运行的效果，这是它们的共同点。</p>
<h3 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h3><ol>
<li>最主要是<code>sleep()</code>没有释放锁，而<code>wait()</code>释放了锁，使得其他线程可以使用同步控制块或者方法。</li>
<li><p>wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用（使用范围）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(x)&#123;</div><div class="line">	x.notify()</div><div class="line">	<span class="comment">//或者wait()</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>这两个方法来自不同的类分别是Thread和Object</p>
</li>
<li><code>sleep</code>必须捕获异常，而<code>wait</code>，<code>notify</code>和<code>notifyAll</code>不需要捕获异常</li>
</ol>
<h2 id="JAVA反射机制"><a href="#JAVA反射机制" class="headerlink" title="JAVA反射机制"></a>JAVA反射机制</h2><ul>
<li>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</li>
<li>Java反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态代理。</li>
</ul>
<h2 id="weak-soft-strong引用的区别"><a href="#weak-soft-strong引用的区别" class="headerlink" title="weak/soft/strong引用的区别"></a>weak/soft/strong引用的区别</h2><ul>
<li>强引用(StrongReference) 是 Java 的默认引用实现,  它会一直存活于 JVM 内， 直到没有任何对象指向它时 GC 执行后才会被回收</li>
<li>弱引用(WeakReference)， 顾名思义,  是一个弱引用,  当所引用的对象在 JVM 内不再有强引用时, GC 后 weak reference 将会被自动回收</li>
<li>软引用SoftReference 于 WeakReference 的特性基本一致， 最大的区别在于 SoftReference 会尽可能长的保留引用直到 JVM 内存不足时才会被回收(虚拟机保证), 这一特性使得 SoftReference 非常适合缓存应用</li>
</ul>
<h2 id="Object的hashCode-与equals-的区别和作用"><a href="#Object的hashCode-与equals-的区别和作用" class="headerlink" title="Object的hashCode()与equals()的区别和作用"></a>Object的hashCode()与equals()的区别和作用</h2><p><code>equals(Object obj)</code>方法用来判断两个对象是否“相同”，如果“相同”则返回true，否则返回false。<br><code>hashcode()</code>方法返回一个int数，在Object类中的默认实现是“将该对象的内部地址转换成一个整数返回”。 </p>
<p>　<strong>在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。</strong>如果不这样做的话，就会违反Object.hashCode的通用约定，从而导致该类无法结合所有基于hashCode的集合一起正常运作，这些集合包含HashMap，HashSet,HashTable。</p>
<p>　这些集合通过对象的<code>hashCode</code>和<code>equals</code>方法判断集合中是否已存着该对象。</p>
<p>　约定：<strong>如果两个对象相同，那么他们的hashcode一定相等，如果两个对象不相同，他们的hashcode可能相同。</strong></p>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">if</span>(obj1.hashCode()==obj2.hashCode())&#123;</div><div class="line">	<span class="keyword">if</span>(obj1.equals(obj2))&#123;</div><div class="line">		<span class="comment">//	集合中已存在该元素；</span></div><div class="line">	&#125;</div><div class="line"> &#125;</div><div class="line"><span class="comment">//集合中不存着该元素</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h2&gt;&lt;p&gt;　一个面向对象的程序（OOP）实际上就是一个相对去中心化、模块化的程序。&lt;/p&gt;
&lt;p&gt;　对于一个OOP来说，它的一个”碎片”，就是一个独立成立、保持自身完整性的单元；它可以和其他的OOP”碎片”整合在一起形成一个可分解的指令结构。&lt;/p&gt;
&lt;p&gt;　“对象”限制了程序漏洞所能造成的损害，有效地对功能实行了隔离，把每个功能都限制在一个可掌控的单元内，这样一来，即使一个对象崩溃了，程序的其他部分也能够继续运转。&lt;br&gt;程序员可以把这个坏掉的单元换掉，就好像我们可以给一个汽车换刹车片一样。&lt;br&gt;软件的销售商可以购买或者销售各种事先编制好的”对象”库给其他的软件研发人员，后者则可以基于这些库里的对象快速地组装起大型软件，而不用再像以前那样重新一行一行的编写新的代码。&lt;br&gt;而到了要为这种大型软件升级的时候，你所要做的就是升级旧的对象或者加入新的对象。&lt;/p&gt;
&lt;p&gt;　再比如：我们做的app，它有许多的功能，每一个功能它对应一个模块。我们通过一个一个实现再把这些模块堆起来，通过我们的接口、方法、回调等把它们组合起来，最后形成我们的面向对象程序，也就是最后生成了我们的app。&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;模块自身应该是单一的、高内聚的，模块与模块之间应该是低耦合的&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Glide加载圆形image第一次只显示占位图的坑</title>
    <link href="http://yoursite.com/2017/01/21/GlideLoadedCircularImageBug/"/>
    <id>http://yoursite.com/2017/01/21/GlideLoadedCircularImageBug/</id>
    <published>2017-01-21T06:03:17.000Z</published>
    <updated>2017-01-21T06:06:41.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Glide加载圆形image第一次只显示占位图的坑"><a href="#Glide加载圆形image第一次只显示占位图的坑" class="headerlink" title="Glide加载圆形image第一次只显示占位图的坑"></a>Glide加载圆形image第一次只显示占位图的坑</h1><p>在使用<a href="https://github.com/bumptech/glide" title="https://github.com/bumptech/glide" target="_blank" rel="external">Glide</a>加载图片时，经常出现图片加载不出来，只显示占位图的情况。</p>
<p>随后我好好的分析了这个问题的触发场景：</p>
<ol>
<li>出现此问题的ImageView都是<a href="https://github.com/hdodenhof/CircleImageView" title="https://github.com/hdodenhof/CircleImageView" target="_blank" rel="external">CircleImageView</a>，其他ImageView的一切正常</li>
<li>出现此问题的ImagView都设置了占位图，不设置一切正常</li>
<li>出现此问题的ImagView加载时都使用了Glide的渐显动画，不使用一切正常</li>
</ol>
<p>所以如果你刚好使用了<a href="https://github.com/hdodenhof/CircleImageView" title="https://github.com/hdodenhof/CircleImageView" target="_blank" rel="external">CircleImageView</a>或者其他的一些自定义的圆形Imageview，而你又刚好设置了占位图的话，那么，你就会遇到这个问题。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案一：不设置占位图；"><a href="#方案一：不设置占位图；" class="headerlink" title="方案一：不设置占位图；"></a>方案一：不设置占位图；</h3><h3 id="方案二：使用Glide的Transformation-API自定义圆形Bitmap的转换。"><a href="#方案二：使用Glide的Transformation-API自定义圆形Bitmap的转换。" class="headerlink" title="方案二：使用Glide的Transformation API自定义圆形Bitmap的转换。"></a>方案二：使用Glide的Transformation API自定义圆形Bitmap的转换。</h3><h3 id="方案三：使用下面的代码加载图片："><a href="#方案三：使用下面的代码加载图片：" class="headerlink" title="方案三：使用下面的代码加载图片："></a>方案三：使用下面的代码加载图片：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Glide.with(mContext)</div><div class="line">    .load(url) </div><div class="line">    .placeholder(R.drawable.ic_default_avatar)</div><div class="line">    .into(<span class="keyword">new</span> SimpleTarget&lt;Bitmap&gt;(width, height) &#123;</div><div class="line">        <span class="meta">@Override</span> </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Bitmap bitmap, GlideAnimation anim)</span> </span>&#123;</div><div class="line">            circleImageView.setImageDrawable(resource); </div><div class="line">        &#125; </div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<h3 id="方案四：不使用Glide的默认动画："><a href="#方案四：不使用Glide的默认动画：" class="headerlink" title="方案四：不使用Glide的默认动画："></a>方案四：不使用Glide的默认动画：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Glide.with(mContext)</div><div class="line">	.load(url) </div><div class="line">	.dontAnimate()</div><div class="line">	.placeholder(R.drawable.ic_default_avatar)</div><div class="line">	.into(circleImageview);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Glide加载圆形image第一次只显示占位图的坑&quot;&gt;&lt;a href=&quot;#Glide加载圆形image第一次只显示占位图的坑&quot; class=&quot;headerlink&quot; title=&quot;Glide加载圆形image第一次只显示占位图的坑&quot;&gt;&lt;/a&gt;Glide加载圆形im
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>OkHttp在4.4及以下不支持TLS协议的解决方法</title>
    <link href="http://yoursite.com/2017/01/21/https-Exception/"/>
    <id>http://yoursite.com/2017/01/21/https-Exception/</id>
    <published>2017-01-21T05:59:58.000Z</published>
    <updated>2017-05-06T06:08:39.984Z</updated>
    
    <content type="html"><![CDATA[<p>在发布水滴preview版的的过程中，5.0以下的手机都不能访问网络。</p>
<p>错误信息如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">javax.net.ssl.SSLHandshakeException: </div><div class="line">javax.net.ssl.SSLProtocolException: </div><div class="line">SSL handshake aborted: ssl=<span class="number">0x79f145b0</span>:</div><div class="line">Failure in SSL library, usually a protocol error error:</div><div class="line"><span class="number">1407742</span>E:SSL routines:SSL23_GET_SERVER_HELLO:tlsv1 alert protocol version</div></pre></td></tr></table></figure>
<p>因为之前没有太多接触过网络协议，这个问题也确实很难搜到，所以我找了很久，才找到了原因：Android 4.4及以下的系统默认不支持TLS协议，所以遇到使用TLS协议的网站就无法访问了。</p>
<p>解决方法如下：创建一个SSLSocketFactoryCompat.java文件，内容如下：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.earlydata.waterdrop.data.net;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.os.Build;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.net.InetAddress;</div><div class="line"><span class="keyword">import</span> java.net.Socket;</div><div class="line"><span class="keyword">import</span> java.net.UnknownHostException;</div><div class="line"><span class="keyword">import</span> java.security.GeneralSecurityException;</div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.HashSet;</div><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.net.ssl.SSLContext;</div><div class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocket;</div><div class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocketFactory;</div><div class="line"><span class="keyword">import</span> javax.net.ssl.X509TrustManager;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SSLSocketFactoryCompat</span> <span class="keyword">extends</span> <span class="title">SSLSocketFactory</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> SSLSocketFactory defaultFactory;</div><div class="line">    <span class="comment">// Android 5.0+ (API level21) provides reasonable default settings</span></div><div class="line">    <span class="comment">// but it still allows SSLv3</span></div><div class="line">    <span class="comment">// https://developer.android.com/about/versions/android-5.0-changes.html#ssl</span></div><div class="line">    <span class="keyword">static</span> String protocols[] = <span class="keyword">null</span>, cipherSuites[] = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            SSLSocket socket = (SSLSocket)SSLSocketFactory.getDefault().createSocket();</div><div class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">/* set reasonable protocol versions */</span></div><div class="line">                <span class="comment">// - enable all supported protocols (enables TLSv1.1 and TLSv1.2 on Android &lt;5.0)</span></div><div class="line">                <span class="comment">// - remove all SSL versions (especially SSLv3) because they're insecure now</span></div><div class="line">                List&lt;String&gt; protocols = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">                <span class="keyword">for</span> (String protocol : socket.getSupportedProtocols())</div><div class="line">                    <span class="keyword">if</span> (!protocol.toUpperCase().contains(<span class="string">"SSL"</span>))</div><div class="line">                        protocols.add(protocol);</div><div class="line">                SSLSocketFactoryCompat.protocols = protocols.toArray(<span class="keyword">new</span> String[protocols.size()]);</div><div class="line">                <span class="comment">/* set up reasonable cipher suites */</span></div><div class="line">                <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123;</div><div class="line">                    <span class="comment">// choose known secure cipher suites</span></div><div class="line">                    List&lt;String&gt; allowedCiphers = Arrays.asList(</div><div class="line">                            <span class="comment">// TLS 1.2</span></div><div class="line">                            <span class="string">"TLS_RSA_WITH_AES_256_GCM_SHA384"</span>,</div><div class="line">                            <span class="string">"TLS_RSA_WITH_AES_128_GCM_SHA256"</span>,</div><div class="line">                            <span class="string">"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256"</span>,</div><div class="line">                            <span class="string">"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"</span>,</div><div class="line">                            <span class="string">"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"</span>,</div><div class="line">                            <span class="string">"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256"</span>,</div><div class="line">                            <span class="string">"TLS_ECHDE_RSA_WITH_AES_128_GCM_SHA256"</span>,</div><div class="line">                            <span class="comment">// maximum interoperability</span></div><div class="line">                            <span class="string">"TLS_RSA_WITH_3DES_EDE_CBC_SHA"</span>,</div><div class="line">                            <span class="string">"TLS_RSA_WITH_AES_128_CBC_SHA"</span>,</div><div class="line">                            <span class="comment">// additionally</span></div><div class="line">                            <span class="string">"TLS_RSA_WITH_AES_256_CBC_SHA"</span>,</div><div class="line">                            <span class="string">"TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA"</span>,</div><div class="line">                            <span class="string">"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"</span>,</div><div class="line">                            <span class="string">"TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA"</span>,</div><div class="line">                            <span class="string">"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"</span>);</div><div class="line">                    List&lt;String&gt; availableCiphers = Arrays.asList(socket.getSupportedCipherSuites());</div><div class="line">                    <span class="comment">// take all allowed ciphers that are available and put them into preferredCiphers</span></div><div class="line">                    HashSet&lt;String&gt; preferredCiphers = <span class="keyword">new</span> HashSet&lt;&gt;(allowedCiphers);</div><div class="line">                    preferredCiphers.retainAll(availableCiphers);</div><div class="line">                    <span class="comment">/* For maximum security, preferredCiphers should *replace* enabled ciphers (thus disabling</span></div><div class="line">                     * ciphers which are enabled by default, but have become unsecure), but I guess for</div><div class="line">                     * the security level of DAVdroid and maximum compatibility, disabling of insecure</div><div class="line">                     * ciphers should be a server-side task */</div><div class="line">                    <span class="comment">// add preferred ciphers to enabled ciphers</span></div><div class="line">                    HashSet&lt;String&gt; enabledCiphers = preferredCiphers;</div><div class="line">                    enabledCiphers.addAll(<span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(socket.getEnabledCipherSuites())));</div><div class="line">                    SSLSocketFactoryCompat.cipherSuites = enabledCiphers.toArray(<span class="keyword">new</span> String[enabledCiphers.size()]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SSLSocketFactoryCompat</span><span class="params">(X509TrustManager tm)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            SSLContext sslContext = SSLContext.getInstance(<span class="string">"TLS"</span>);</div><div class="line">            sslContext.init(<span class="keyword">null</span>, (tm != <span class="keyword">null</span>) ? <span class="keyword">new</span> X509TrustManager[] &#123; tm &#125; : <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">            defaultFactory = sslContext.getSocketFactory();</div><div class="line">        &#125; <span class="keyword">catch</span> (GeneralSecurityException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(); <span class="comment">// The system has no TLS. Just give up.</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">upgradeTLS</span><span class="params">(SSLSocket ssl)</span> </span>&#123;</div><div class="line">        <span class="comment">// Android 5.0+ (API level21) provides reasonable default settings</span></div><div class="line">        <span class="comment">// but it still allows SSLv3</span></div><div class="line">        <span class="comment">// https://developer.android.com/about/versions/android-5.0-changes.html#ssl</span></div><div class="line">        <span class="keyword">if</span> (protocols != <span class="keyword">null</span>) &#123;</div><div class="line">            ssl.setEnabledProtocols(protocols);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP &amp;&amp; cipherSuites != <span class="keyword">null</span>) &#123;</div><div class="line">            ssl.setEnabledCipherSuites(cipherSuites);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> String[] getDefaultCipherSuites() &#123;</div><div class="line">        <span class="keyword">return</span> cipherSuites;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> String[] getSupportedCipherSuites() &#123;</div><div class="line">        <span class="keyword">return</span> cipherSuites;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Socket <span class="title">createSocket</span><span class="params">(Socket s, String host, <span class="keyword">int</span> port, <span class="keyword">boolean</span> autoClose)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        Socket ssl = defaultFactory.createSocket(s, host, port, autoClose);</div><div class="line">        <span class="keyword">if</span> (ssl <span class="keyword">instanceof</span> SSLSocket)</div><div class="line">            upgradeTLS((SSLSocket)ssl);</div><div class="line">        <span class="keyword">return</span> ssl;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Socket <span class="title">createSocket</span><span class="params">(String host, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException, UnknownHostException </span>&#123;</div><div class="line">        Socket ssl = defaultFactory.createSocket(host, port);</div><div class="line">        <span class="keyword">if</span> (ssl <span class="keyword">instanceof</span> SSLSocket)</div><div class="line">            upgradeTLS((SSLSocket)ssl);</div><div class="line">        <span class="keyword">return</span> ssl;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Socket <span class="title">createSocket</span><span class="params">(String host, <span class="keyword">int</span> port, InetAddress localHost, <span class="keyword">int</span> localPort)</span> <span class="keyword">throws</span> IOException, UnknownHostException </span>&#123;</div><div class="line">        Socket ssl = defaultFactory.createSocket(host, port, localHost, localPort);</div><div class="line">        <span class="keyword">if</span> (ssl <span class="keyword">instanceof</span> SSLSocket)</div><div class="line">            upgradeTLS((SSLSocket)ssl);</div><div class="line">        <span class="keyword">return</span> ssl;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Socket <span class="title">createSocket</span><span class="params">(InetAddress host, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        Socket ssl = defaultFactory.createSocket(host, port);</div><div class="line">        <span class="keyword">if</span> (ssl <span class="keyword">instanceof</span> SSLSocket)</div><div class="line">            upgradeTLS((SSLSocket)ssl);</div><div class="line">        <span class="keyword">return</span> ssl;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Socket <span class="title">createSocket</span><span class="params">(InetAddress address, <span class="keyword">int</span> port, InetAddress localAddress, <span class="keyword">int</span> localPort)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        Socket ssl = defaultFactory.createSocket(address, port, localAddress, localPort);</div><div class="line">        <span class="keyword">if</span> (ssl <span class="keyword">instanceof</span> SSLSocket)</div><div class="line">            upgradeTLS((SSLSocket)ssl);</div><div class="line">        <span class="keyword">return</span> ssl;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在创建OkHttpClient的时候，添加这个SSLSocketFactory（我用单例模式来每次获取同一个全局的OkHttpClient，每个人的实现不一定一样，从我的代码里参考问题的解决方法就好）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">OkHttpClient.Builder clientBuilder = <span class="keyword">new</span> OkHttpClient.Builder();</div><div class="line">         </div><div class="line">          <span class="comment">// 自定义一个信任所有证书的TrustManager，添加SSLSocketFactory的时候要用到</span></div><div class="line">          <span class="keyword">final</span> X509TrustManager trustAllCert =</div><div class="line">                  <span class="keyword">new</span> X509TrustManager() &#123;</div><div class="line">                      <span class="meta">@Override</span></div><div class="line">                      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(java.security.cert.X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      <span class="meta">@Override</span></div><div class="line">                      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(java.security.cert.X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      <span class="meta">@Override</span></div><div class="line">                      <span class="keyword">public</span> java.security.cert.X509Certificate[] getAcceptedIssuers() &#123;</div><div class="line">                          <span class="keyword">return</span> <span class="keyword">new</span> java.security.cert.X509Certificate[]&#123;&#125;;</div><div class="line">                      &#125;</div><div class="line">                  &#125;;</div><div class="line">SSLSocketFactory sslSocketFactory = <span class="keyword">new</span> SSLSocketFactoryCompat(trustAllCert);</div><div class="line">clientBuilder.sslSocketFactory(sslSocketFactory, trustAllCert);</div></pre></td></tr></table></figure>
<p>这样就可以解决了～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在发布水滴preview版的的过程中，5.0以下的手机都不能访问网络。&lt;/p&gt;
&lt;p&gt;错误信息如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;javax.net.ssl.SSLHandshakeException: &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;javax.net.ssl.SSLProtocolException: &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;SSL handshake aborted: ssl=&lt;span class=&quot;number&quot;&gt;0x79f145b0&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Failure in SSL library, usually a protocol error error:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1407742&lt;/span&gt;E:SSL routines:SSL23_GET_SERVER_HELLO:tlsv1 alert protocol version&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为之前没有太多接触过网络协议，这个问题也确实很难搜到，所以我找了很久，才找到了原因：Android 4.4及以下的系统默认不支持TLS协议，所以遇到使用TLS协议的网站就无法访问了。&lt;/p&gt;
&lt;p&gt;解决方法如下：创建一个SSLSocketFactoryCompat.java文件，内容如下：&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>如何遍写测试用例</title>
    <link href="http://yoursite.com/2017/01/20/article-title/"/>
    <id>http://yoursite.com/2017/01/20/article-title/</id>
    <published>2017-01-20T15:55:29.000Z</published>
    <updated>2017-01-21T10:34:11.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何遍写测试用例"><a href="#如何遍写测试用例" class="headerlink" title="如何遍写测试用例"></a>如何遍写测试用例</h1><p>测试代码主要分为java单元测试用例和Android测试用例。</p>
<ul>
<li>java单元测试用例 ： 主要是业务逻辑和数据相关，独立于Android 不需要跑在 Android 设备上</li>
<li>Android 测试用例 ： 主要是UI相关，这类 case 必须要运行在 android 设备上</li>
</ul>
<h2 id="哪些东西需要测试呢？"><a href="#哪些东西需要测试呢？" class="headerlink" title="哪些东西需要测试呢？"></a>哪些东西需要测试呢？</h2><ul>
<li><p>所有的Model、Presenter/ViewModel、Api、Utils等类的public方法</p>
</li>
<li><p>Data类除了getter、setter、toString、hashCode等一般自动生成的方法之外的逻辑部分</p>
</li>
<li><p>自定义View的功能：比如set data以后，text有没有显示出来等等，简单的交互，比如click事件，负责的交互一般不测，比如touch、滑动事件等等。</p>
</li>
<li><p>Activity的主要功能：比如view是不是存在、显示数据、错误信息、简单的点击事件等。比较复杂的用户交互比如onTouch，以及view的样式、位置等等可以不测。因为不好测。</p>
</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>在Android Studio中进行单元测试并不需要什么插件或者过多的配置，Android Studio本身就集成了测试环境，无论是单纯的java代码单元测试还是依赖Android SDK的Android代码单元测试，都能得心应手。</p>
<p>首先在你的gradle中加入Junit的依赖，注意这里的依赖方式是测试期间的依赖（testCompile）：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    testCompile <span class="string">'junit:junit:4.12'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>默认建立的结构如下：</p>
<p><img src="http://7xq7yd.com1.z0.glb.clouddn.com/s0.png" alt="默认结构"> </p>
<h2 id="编写Java测试用例"><a href="#编写Java测试用例" class="headerlink" title="编写Java测试用例"></a>编写Java测试用例</h2><p>如果所写的测试代码没有使用android sdk（android.<em>*</em>下的代码），那么可以在test目录下新建，本例中即为ExampleUnitTest，例子中测试了一个RxJava的Observable的发射后被消费的结果。</p>
<p>注意测试用例即一个public void的方法，并且加上@Test注解，这是Junit的标准用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.earlydata.waterdrop;</div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"><span class="keyword">import</span> rx.Observer;</div><div class="line"><span class="keyword">import</span> rx.subjects.PublishSubject;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleUnitTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPublishSubject</span><span class="params">()</span> </span>&#123;</div><div class="line">        PublishSubject&lt;String&gt; stringPublishSubject = PublishSubject.create();</div><div class="line">        stringPublishSubject.subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"Observable completed"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"Observer consumed "</span> + s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        stringPublishSubject.onNext(<span class="string">"hello world"</span>);</div><div class="line">        stringPublishSubject.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时候打开Android Studio左边的Structure的面板，可以看到测试用例方法testPublishSubject</p>
<p><img src="http://7xq7yd.com1.z0.glb.clouddn.com/s1.jpg" alt="测试用例方法testPublishSubject"> </p>
<p>右击并运行它，测试通过，返回了正确的值</p>
<p><img src="http://7xq7yd.com1.z0.glb.clouddn.com/s3.jpg" alt="正确的值"> </p>
<p>注意本测试用例试用了System.out.println所以测试结果直接打印在了控制台上，如果把打印的地方换成Log.d()呢，你会发现报错：</p>
<p><img src="http://7xq7yd.com1.z0.glb.clouddn.com/s4.jpg" alt="报错"> </p>
<p>这个实际是因为你在java的Unit test中引用了Android的代码，即android.util.log.Log。所以对于测试Android代码，需要在androidTest中</p>
<h2 id="编写Android测试用例"><a href="#编写Android测试用例" class="headerlink" title="编写Android测试用例"></a>编写Android测试用例</h2><p>Android 测试用例主要是对Espresso API的使用，以下系列文章是对Espresso官方文档的翻译(偷个懒)</p>
<p><a href="http://www.jianshu.com/p/ef4ad5424784" title="http://www.jianshu.com/p/ef4ad542478" target="_blank" rel="external">1. Espresso 概览</a></p>
<p><a href="http://www.jianshu.com/p/92c7f6dbf80d" title="http://www.jianshu.com/p/92c7f6dbf80d" target="_blank" rel="external">2. Espresso 设置说明</a></p>
<p><a href="http://www.jianshu.com/p/9e8e8e5f09d6" title="http://www.jianshu.com/p/9e8e8e5f09d6" target="_blank" rel="external">3. Espresso 基础</a></p>
<p><a href="http://www.jianshu.com/p/cf1079954da5" title="http://www.jianshu.com/p/cf1079954da5" target="_blank" rel="external">4. Espresso 备忘录</a></p>
<p><a href="http://www.jianshu.com/p/5de7c560fe33" title="http://www.jianshu.com/p/5de7c560fe33" target="_blank" rel="external">5. Espresso 意图</a></p>
<p><a href="http://www.jianshu.com/p/4166b92fee1c" title="http://www.jianshu.com/p/4166b92fee1c" target="_blank" rel="external">6. Espresso 高级示例</a></p>
<p><a href="http://www.jianshu.com/p/e2d37d04e95e" title="http://www.jianshu.com/p/e2d37d04e95e" target="_blank" rel="external">7. Espresso Web</a></p>
<p><a href="http://www.jianshu.com/p/9ee72ec7f782" title="http://www.jianshu.com/p/9ee72ec7f782" target="_blank" rel="external">8. AndroidJUnitRunner</a></p>
<p><a href="http://www.jianshu.com/p/6a32d44eb5ad" title="http://www.jianshu.com/p/6a32d44eb5ad" target="_blank" rel="external">9. ATSL 中的 JUnit4 规则</a></p>
<p><a href="http://www.jianshu.com/p/093645e32011" title="http://www.jianshu.com/p/093645e32011" target="_blank" rel="external">10. UI Automator</a></p>
<p><a href="http://www.jianshu.com/p/29671943b69c" title="http://www.jianshu.com/p/29671943b69c" target="_blank" rel="external">11. 可访问性检查</a></p>
<p>其他资料</p>
<p><a href="http://chriszou.com/2016/06/07/android-unit-testing-everything-you-need-to-know.html?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" title="http://chriszou.com/2016/06/07/android-unit-testing-everything-you-need-to-know.html?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">关于安卓单元测试，你需要知道的一切</a></p>
<p><a href="http://www.jianshu.com/p/4f019c1c04a2" title="http://www.jianshu.com/p/4f019c1c04a2" target="_blank" rel="external">使用 Espresso 进行 Android UI 测试</a></p>
<p><a href="http://www.jianshu.com/p/37a3f68934cd" title="http://www.jianshu.com/p/37a3f68934cd" target="_blank" rel="external">Android UI 测试框架 Espresso</a></p>
<p><a href="http://www.jianshu.com/p/c265a781c8ce" title="http://www.jianshu.com/p/c265a781c8ce" target="_blank" rel="external">Android 测试代码编写小技巧 - UI 和 单元测试间共享代码</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何遍写测试用例&quot;&gt;&lt;a href=&quot;#如何遍写测试用例&quot; class=&quot;headerlink&quot; title=&quot;如何遍写测试用例&quot;&gt;&lt;/a&gt;如何遍写测试用例&lt;/h1&gt;&lt;p&gt;测试代码主要分为java单元测试用例和Android测试用例。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;java单元测试用例 ： 主要是业务逻辑和数据相关，独立于Android 不需要跑在 Android 设备上&lt;/li&gt;
&lt;li&gt;Android 测试用例 ： 主要是UI相关，这类 case 必须要运行在 android 设备上&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;哪些东西需要测试呢？&quot;&gt;&lt;a href=&quot;#哪些东西需要测试呢？&quot; class=&quot;headerlink&quot; title=&quot;哪些东西需要测试呢？&quot;&gt;&lt;/a&gt;哪些东西需要测试呢？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;所有的Model、Presenter/ViewModel、Api、Utils等类的public方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Data类除了getter、setter、toString、hashCode等一般自动生成的方法之外的逻辑部分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自定义View的功能：比如set data以后，text有没有显示出来等等，简单的交互，比如click事件，负责的交互一般不测，比如touch、滑动事件等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Activity的主要功能：比如view是不是存在、显示数据、错误信息、简单的点击事件等。比较复杂的用户交互比如onTouch，以及view的样式、位置等等可以不测。因为不好测。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Github搭建自己的博客</title>
    <link href="http://yoursite.com/2017/01/20/hello-world/"/>
    <id>http://yoursite.com/2017/01/20/hello-world/</id>
    <published>2017-01-20T13:25:12.642Z</published>
    <updated>2017-01-20T16:00:51.371Z</updated>
    
    <content type="html"><![CDATA[<p>　本人一直都泡在CSDN，简书，知乎等论坛，爱关注大牛博客。</p>
<p>　看了<a href="http://blog.csdn.net/gdutxiaoxu/article/details/53576018" title="手把手教你用Hexo+Github 搭建属于自己的博客 " target="_blank" rel="external">《手把手教你用Hexo+Github 搭建属于自己的博客》</a>之后决定搭建自己的博客，开始养成写博客的习惯。</p>
<p>　写文章会锻炼许多对于编程十分有益的技能。即使没人读我的文章，写作的过程也是有益无害。它能帮助我理清思路，明确对于某个问题的看法，加强或削弱我的某种观点。把凌乱的想法汇聚成精简的文字非常有价值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本人一直都泡在CSDN，简书，知乎等论坛，爱关注大牛博客。&lt;/p&gt;
&lt;p&gt;　看了&lt;a href=&quot;http://blog.csdn.net/gdutxiaoxu/article/details/53576018&quot; title=&quot;手把手教你用Hexo+Github 搭建属于
    
    </summary>
    
    
  </entry>
  
</feed>
