<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android 开发规范]]></title>
    <url>%2F2017%2F06%2F17%2FAndroid%20%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[为了利于项目维护以及规范开发，促进成员之间Code Review的效率，故提出以下开发规范，如有更好建议，欢迎提出 另外，BoilerPlate 是一个很好的参考材料和学习项目，你对MVP架构会有一个新的认识。 1 Android Studio规范 尽量使用最新版本的Android Studio开发 编码格式统一为UTF-8 编辑完.java、 .xml等文件后一定要格式化,一定要格式化,一定要格式化，格式使用IDE默认模板即可（快捷键：Ctrl+Alt+L） 删除多余的import，减少警告出现，可利用IDE的Optimize Imports自动优化(Settings → Keymap → Optimize Imports) Android Studio 常用开发插件可以参考这里~Android Studio插件整理 2 命名规范代码中的命名严禁使用拼音与英文混合的方式,更不允许直接使用中文的方式。正确的英文拼写和语法可以让阅读者易于理解,避免歧义。 注意：即使纯拼音命名方式也要避免采用。但alibaba、taobao、youku、zhihu等国际通用的名称,可视同英文。 2.1 包命名规范 包名全部小写，连续的单词只是简单地连接起来，不使用下划线，采用反域名命名规则，全部使用小写字母。 包名的划分，尽量使用按功能模块的划分方式。按照功能模块划分可能你不是很好区分应该划分在哪个功能中，不过也比你按照层区划分要好找很多。具体可以参考这篇博文～Package by features, not layers 通用功能子包名采用[主包名].[通用名称]的命名方式常见通用功能如下表： 包名 | 包下的类工作划分 —– |—— base |基类相关 utils |通用工具类 event |事件载体类(EventBus事件对象) rx |RxJava相关帮助类 pref |用户设置、全局配置、常量等 bean |数据载体类，javaBean domain |model层，业务逻辑 data |model层，数据操作、数据提供，等数据相关类 presentation|视图层，包含View层和Present层。如：Activity、Fragment、Presenter 一般功能子包名采用[主包名].[模块名称].[子模块名称]的命名方式，例如： 模块 | 包名 —– |—— 网络相关|[主包名].data.net 登录模块|[主包名].presentation.login 我的模块|[主包名].presentation.mine 只需导入用到的类，千万不能用 * 导入包下所有类 2.2 Class files 类命名规范类命名方式采用 大驼峰 命名法。尽量避免缩写，除非该缩写是众所周知的。 对于继承自安卓组件的类来说，类名应该以该组件名结尾，例如 ： SignInActivity, SignInFragment, ImageUploaderService, ChangePasswordDialog.对于工具类来说，命名方式应该以其完成功能开始,以 Utils 结束 ，例如 ：HttpUtils , ImageUtils 2.3 Resources files 资源文件命名规范全部小写，采用下划线命名法，加前缀区分 Layout files布局文件的命名需要与他所嵌入的安卓组件匹配，但是将组件名称前移到开始处,例如,我们要创建一个名字为 SignInActivity, 其名字应该为 activity_sign_in.xml. Component 组件 Class Name Layout Name Activity UserProfileActivity activity_user_profile.xml Fragment SignUpFragment fragment_sign_up.xml Dialog ChangePasswordDialog dialog_change_password.xml ListView Item — list_item_person.xml GridView Item — grid_item_person.xml Drawable files drawable 文件的命名规范 Asset Type|Prefix 前缀|Example ——–|——–|——– Action bar|ab_|ab_stacked.9.png Button |btn_ |btn_send_pressed.9.png Dialog |dialog_ |dialog_top.9.png Divider |divider_ |divider_horizontal.9.png Icon |ic_ |ic_star.png Menu| menu_| menu_submenu_bg.9.png Notification| notification_| notification_bg.9.png Tabs |tab_ |tab_pressed.9.png icons文件的命名规范 | Asset Type | Prefix 前缀 | Example | | ——————————–| —————- | —————————- | | Icons | ic_ | ic_star.png | | Launcher icons | ic_launcher | ic_launcher_calendar.png | | Menu icons and Action Bar icons | ic_menu | ic_menu_archive.png | | Status bar icons | ic_stat_notify | ic_stat_notify_msg.png | | Tab icons | ic_tab | ic_tab_recent.png | | Dialog icons | ic_dialog | ic_dialog_info.png | 选择器状态文件的命名规范 | State | Suffix 尾缀 | Example | |————–|—————–|—————————–| | Normal | _normal | btn_order_normal.9.png | | Pressed | _pressed | btn_order_pressed.9.png | | Focused | _focused | btn_order_focused.9.png | | Disabled | _disabled | btn_order_disabled.9.png | | Selected | _selected | btn_order_selected.9.png | 注意：使用AndroidStudio的插件SelectorChapek可以快速生成selector，前提是命名要规范。 2.4 Inside Code Naming 代码内部命名2.4.1 常量名常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。那到底什么算是一个常量？ 每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时，考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。 1234567891011121314// Constantsstatic final int NUMBER = 5;static final ImmutableListNAMES = ImmutableList.of("Ed", "Ann");static final Joiner COMMA_JOINER = Joiner.on(','); // because Joiner is immutablestatic final SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;enum SomeEnum &#123; ENUM_CONSTANT &#125;// Not constantsstatic String nonFinal = "non-final";final String nonStatic = "non-static";static final Set mutableCollection = new HashSet();static final ImmutableSet mutableElements = ImmutableSet.of(mutable);static final Logger logger = Logger.getLogger(MyClass.getName());static final String[] nonEmptyArray = &#123;"these", "can", "change"&#125;; 2.4.2 Class Variable Naming 类变量命名 公有变量按 小驼峰 法命名 私有 &amp; 非静态成员变量以 m 开头 私有 &amp; 静态成员变量以 s 开头 常量以大写字母和下划线 _ 组成 尽量使用 功能/描述 + 类型 的模式 ,如 mNameTextView 类中变量的组件类型请不要使用缩写 自定义异常必须以Exception结尾 注意不要使用 aa bb cc3 这种变态的命名方式 ！！ 除for循环变量外，一律不得使用i、j、k等单字符作为变量名 类变量过多时请 分块摆放 并且 写好注释 接口类 请直接定义在类的最后 Example: 1234567891011121314public class MyClass &#123; //静态常量 public static final int SOME_CONSTANT = 42; //公有变量 public int publicField; //私有静态变量 private static MyClass sSingleton; //默认变量 int mPackagePrivate; //私有变量 private int mPrivate; //继承型变量 protected int mProtected;&#125; 注意：如果项目中使用ButterKnife，则不添加m前缀，以小驼峰风格命名。 2.4.3 Class Method Naming 类方法命名 类方法采用 小驼峰 命名法 根据函数所完成功能命名 ， 如 changView() 在函数头写对于函数功能、参数和返回值的注释，如： 12345678910/** * 获取两个数中最大的一个 * * @param value1 参与比较的第一个数 * @param value2 参与比较的第二个数 * @return 两个参数中最大的一个数 */public int max(int value1, int value2) &#123; return (value1 &gt; value2) ? value1 : value2;&#125; 一个函数请尽量保持在 50行 之内 ！！ 2.4.4 layout.xml 布局文件变量命名 id 以 类型命名所在组件 的模式，例如： @+id/tv_name_main 、 @id/btn_send_chat,多数情况 _所在模块可省略，如：@id/btn_send 布局多处重用的请使用 &lt;include&gt; 标签 所有文本请定义在 strings.xml 中 , 如 @string/app_name 重用dp请定义在 dimens.xml 中 , 如 @dimen/entry_item_height Component 组件 Abbreviation 缩写 ListView lv TextView tv ImageView iv Button btn EditText et LinearLayout ll ReleativeLayout rl ViewPager vp 2.4.5 colors.xmlcolors的name命名使用下划线命名法，在你的colors.xml文件中应该只是映射颜色的名称一个ARGB值，而没有其它的。不要使用它为不同的按钮来定义ARGB值。 不要这样做12345678910 &lt;resources&gt; &lt;color name="button_foreground"&gt;#FFFFFF&lt;/color&gt; &lt;color name="button_background"&gt;#2A91BD&lt;/color&gt; &lt;color name="comment_background_inactive"&gt;#5F5F5F&lt;/color&gt; &lt;color name="comment_background_active"&gt;#939393&lt;/color&gt; &lt;color name="comment_foreground"&gt;#FFFFFF&lt;/color&gt; &lt;color name="comment_foreground_important"&gt;#FF9D2F&lt;/color&gt; ... &lt;color name="comment_shadow"&gt;#323232&lt;/color&gt;&lt;resources&gt; 使用这种格式，你会非常容易的开始重复定义ARGB值，这使如果需要改变基本色变的很复杂。同时，这些定义是跟一些环境关联起来的，如button或者comment, 应该放到一个按钮风格中，而不是在color.xml文件中。 相反，这样做 123456789101112131415161718192021&lt;resources&gt; &lt;!--主色--&gt; &lt;color name="colorPrimary"&gt;#ff149BCC&lt;/color&gt;&lt;!--主色调--&gt; &lt;color name="colorPrimaryDark"&gt;#ff1976D2&lt;/color&gt;&lt;!--在Material Design，对应状态栏颜色--&gt; &lt;color name="colorAccent"&gt;#ff0EC7F0&lt;/color&gt; &lt;!--强调色 --&gt; &lt;color name="colorGrounding"&gt;#ffF4F3F1&lt;/color&gt;&lt;!--界面底色--&gt; &lt;color name="colorRipple"&gt;#B2EBF2&lt;/color&gt;&lt;!--点击时水波纹颜色--&gt; &lt;!--文字颜色--&gt; &lt;color name="textPrimary"&gt;#172434&lt;/color&gt; &lt;color name="textSecondary"&gt;#666666&lt;/color&gt; &lt;color name="textPrimaryInverted"&gt;@color/white&lt;/color&gt; &lt;color name="textSecondaryInverted"&gt;@color/white_A50&lt;/color&gt; &lt;!--通用颜色--&gt; &lt;color name="blue"&gt;#ff1976D2&lt;/color&gt; &lt;color name="blue_light"&gt;#ff149BCC&lt;/color&gt; &lt;color name="white"&gt;#ffffffff&lt;/color&gt; &lt;color name="white_A50"&gt;#80ffffff&lt;/color&gt;&lt;!--50%透明度--&gt; &lt;color name="yellow"&gt;#f59800&lt;/color&gt;&lt;/resources&gt; 向应用设计者那里要这个调色板，名称不需要跟green、blue等等相同。brand_primary、brand_secondary、brand_negative这样的名字也是完全可以接受的。 像这样规范的颜色很容易修改或重构，会使应用一共使用了多少种不同的颜色变得非常清晰。 通常一个具有审美价值的UI来说，减少使用颜色的种类是非常重要的。 2.4.6 dimens.xml像对待colors.xml一样对待dimens.xml文件 与定义颜色调色板一样，你同时也应该定义一个空隙间隔和字体大小的“调色板”。 一个好的例子，如下所示：12345678910111213141516171819202122&lt;resources&gt; &lt;!--font sizes--&gt; &lt;dimen name="font_micro"&gt;10.0sp&lt;/dimen&gt; &lt;dimen name="font_small"&gt;12.0sp&lt;/dimen&gt; &lt;dimen name="font_medium"&gt;14.0sp&lt;/dimen&gt; &lt;dimen name="font_large"&gt;16.0sp&lt;/dimen&gt; &lt;dimen name="font_xlarge"&gt;18.0sp&lt;/dimen&gt; &lt;dimen name="font_extra_large"&gt;22.0sp&lt;/dimen&gt; &lt;!-- typical spacing between two views --&gt; &lt;dimen name="spacing_huge"&gt;40dp&lt;/dimen&gt; &lt;dimen name="spacing_large"&gt;24dp&lt;/dimen&gt; &lt;dimen name="spacing_normal"&gt;14dp&lt;/dimen&gt; &lt;dimen name="spacing_small"&gt;10dp&lt;/dimen&gt; &lt;dimen name="spacing_tiny"&gt;4dp&lt;/dimen&gt; &lt;!--布局规范--&gt; &lt;dimen name="toolbar_height"&gt;48dp&lt;/dimen&gt; &lt;dimen name="bottomBar_height"&gt;56dp&lt;/dimen&gt; &lt;dimen name="tab_height"&gt;40dp&lt;/dimen&gt; &lt;dimen name="row_view_height"&gt;48dp&lt;/dimen&gt;&lt;/resources&gt; 布局时在写margins和paddings时，你应该使用spacing_xxxx尺寸格式来布局，而不是像对待string字符串一样直接写值。 这样写会非常有感觉，会使组织和改变风格或布局是非常容易。 2.4.7 styles.xmlstyle的name命名使用大驼峰命名法例如： 1234&lt;style name="ContentText"&gt; &lt;item name="android:textSize"&gt;@dimen/font_normal&lt;/item&gt; &lt;item name="android:textColor"&gt;@color/basic_black&lt;/item&gt;&lt;/style&gt; 将一个大的style文件分割成多个文件， 你可以有多个styles.xml 文件。Android SDK支持其它文件，styles这个文件名称并没有作用，起作用的是在文件 里xml的&lt;style&gt;标签。因此你可以有多个style文件styles.xml、style_home.xml、style_item_details.xml、styles_forms.xml。 不同于资源文件路径需要为系统构建起的有意义，在res/values目录下的文件可以任意命名。 参考资料Android-Code-Style Android开发规范 Android开发规范和架构总结]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android 代码规范]]></title>
    <url>%2F2017%2F06%2F17%2FAndroid%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[多用组合, 少用继承 如果继承很重,那么子类不管要不要，有没有用，都会拥有父类的所有东西，影响子类性能造成代码冗余.继承可能破坏封装：因为子类和父类之间可能存在着实现细节的依赖.子类在继承父类的时候，往往不得不关注父类的实现细节，而父类在修改其内部实现的时候，如果不考虑子类，也往往会影响到子类. 一般try…catch…只捕获需要的异常，谨慎地使用异常，异常捕获的代价非常高昂，异常使用过多会严重影响程序的性能。参考Java异常处理和设计第五点 try…catch…中，catch…块不得为空，至少应当将异常信息输出 不要在循环中使用try…catch…，应该把其放在最外层 当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按递增顺序（参数多的写在后面）出现在一起，中间不要放进其它函数/方法。例如： 1234567public GameView(Context context) &#123; this(context, null);&#125;public GameView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0);&#125;public GameView(Context context, AttributeSet attrs, int defStyle) &#123;&#125; 把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据 + &quot;&quot;最慢 静态成员：使用类进行调用 使用类名调用静态的类成员，而不是具体某个对象或表达式。 1234Foo aFoo = ...;Foo.aStaticMethod(); // goodaFoo.aStaticMethod(); // badsomethingThatYieldsAFoo().aStaticMethod(); // very bad EventBus、RxBus 不可将String、int等作为消息类型传递，每个不同的事件都应定义一个Class类，哪怕这个类没有任何属性和方法。 有这样的场景，就是我们发送事件时，有时候这个事件不含任何数据，只是一个简单的通知。 有的小伙伴可能就会想到通过发送String或者int常量，在接收时判断相等来区分事件类型，这个一种不太好的做法。 因为Rxbus是根据Class类型来过滤订阅者发送消息的，如果过度使用这种方式会直接导致RxBus在每次发射这类数据时，因订阅者的过多而使发射效率变慢。 所以最好为每个不同的事件都定义一个Class类，哪怕这个类没有任何属性和方法，以达到最高效率。 intent 传递Extras的key值禁止使用硬编码，请使用常量。 最好不要以new的方式创建Fragment，推荐使用静态工厂方法模式创建Fragment. 例如： 12345 public static HomeFragment newInstance() &#123; return new HomeFragment(); &#125;HomeFragment home=HomeFragment.newInstance();//goodHomeFragment home=new HomeFragment();//bad 合理布局，有效运用&lt;merge&gt;、&lt;ViewStub&gt;、&lt;include&gt;标签 使用RxJava时，在不影响代码可读性的情况下，尽量减少操作符的使用. 刚开始使用RxJava的时候，我们会觉得operator的链式调用会非常的爽，一个简单的例子： 12345678Observable.just("1", "2", "3", "4", "5", "6", "7") .map(x -&gt; Integer.valueOf(x)) .map(x -&gt; x * 2) .map(x -&gt; x + 4) .filter(x -&gt; x &gt;2) // and much more operators .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()); 当你只有很少数据的时候，这样当然可以，但是你数据量上来的时候，这就会有很多的overhead。 其实几乎所有的operator都会给你生成一个新的Observable。所以在上面这个例子中，我们在过程中生成了至少7个Observable。然而我们完全可以将中间的.map().map().map().filter合并在一个FlatMap中，减少很多的overhead。 updating…]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React Native学习笔记(二)]]></title>
    <url>%2F2017%2F06%2F04%2Freact-native2%2F</url>
    <content type="text"><![CDATA[导入导出变量 导出变量 在每个变量前加上export关键字，即可导出 123export var name='zchu';export var age=25;export const url='zchu.githun.io'; 或者你觉得每个都要加关键字，想一步到位，则可以用这种方式导出 1234var name = 'zchu';var age = 25;const url = 'zchu.githun.io';export &#123;name, age, url&#125;//批量导出 导出方法 同样也是使用export关键字导出 123export function sum(a, b) &#123; return a+b;&#125; 导入变量和方法是一样的 1import &#123;文件名&#125;,&#123;name,age,url,sum&#125; from '&#123;文件路径&#125;' 使用导入的变量和方法 1234567&lt;Text&gt;name:&#123;name&#125;&lt;/Text&gt;&lt;Text onPress=&#123;()=&gt;&#123; Alert.alert("总数为"+sum(5,7)) &#125;&#125;&gt;&gt;age:&#123;age&#125;&lt;/Text&gt;... props使用详解大多数组件在创建时就可以使用各种参数来进行定制。用于定制的这些参数就称为props（属性）。 通过在不同的场景使用不同的属性定制，可以尽量提高自定义组件的复用范畴。只需在render函数中引用this.props，然后按需处理即可。下面是一个自定义的组件使用props的例子：123456789101112131415161718192021222324import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, Text, View &#125; from 'react-native';class Greeting extends Component &#123; render() &#123; return ( &lt;Text&gt;Hello &#123;this.props.name&#125;!&lt;/Text&gt; ); &#125;&#125;class LotsOfGreetings extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123;alignItems: 'center'&#125;&#125;&gt; &lt;Greeting name='Rexxar' /&gt; &lt;Greeting name='Jaina' /&gt; &lt;Greeting name='Valeera' /&gt; &lt;/View&gt; ); &#125;&#125;AppRegistry.registerComponent('LotsOfGreetings', () =&gt; LotsOfGreetings); 我们在Greeting组件中将name作为一个属性来定制，这样可以复用这一组件来制作各种不同的“问候语”。]]></content>
      <tags>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native学习笔记(一)]]></title>
    <url>%2F2017%2F05%2F23%2Freact-native1%2F</url>
    <content type="text"><![CDATA[创建React Native 项目到你想要存放React-Native项目的目录执行react-native init {项目} 即可初始化一个新的React-Native项目 创建完成后即可看到index.android.js和index.ios.js还有其他文件。 让android和ios加载同一部分代码 新创建一个setup.js，名字可随意不一定得是setup.js，但不能是index.js。内容可直接复制index.android.js或index.ios.js的代码，修改下名字即可。 123456789101112import ...export default class setup extends Component &#123; render() &#123; return ( ... ); &#125;&#125;... 将setup导入到index.android和index.ios 12345678import React, &#123; Component &#125; from 'react';import &#123; AppRegistry&#125; from 'react-native';import setup from './setup'AppRegistry.registerComponent('study', () =&gt; setup); 这样一来app启动之后不管是访问index.android还是index.ios都会指向setup，在setup里面做的所有修改都可以运行在android和ios设备上。 创建react-native组件这里只简单说明ES6创建组件的方式，新建一个MyComponent.js：123456789101112131415import React, &#123; Component &#125; from 'react';import &#123; Text&#125; from 'react-native';// 用export default 将其导出 export default class MyComponent extends Component &#123; render() &#123; return ( &lt;Text style=&#123;&#123;fontSize:22,color : '#212121'&#125;&#125;&gt; Hello.&#123;this.props.name&#125; &lt;/Text&gt; ); &#125;&#125; 在setup中使用：12345678910111213141516171819import React, &#123; Component &#125; from 'react';import &#123; AppRegistry&#125; from 'react-native';//导入MyComponent 组件import MyComponent from './MyComponent'export default class setup extends Component &#123; render() &#123; return ( &lt;MyComponent name="MyComponent"/&gt; ); &#125;&#125;AppRegistry.registerComponent('study', () =&gt; setup); 显示效果 react-native组件的生命周期在iOS中UIViewController提供了(void)viewWillAppear:(BOOL)animated, - (void)viewDidLoad,(void)viewWillDisappear:(BOOL)animated等生命周期方法，在Android中Activity则提供了 onCreate(),onStart(),onResume() ,onPause(),onStop(),onDestroy()等生命周期方法，这些生命周期方法展示了一个界面从创建到销毁的一生 那么在React 中组件(Component)也是有自己的生命周期方法的。 组件的生命周期分成三个状态： Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM 组件装载组件在渲染之前，会先调用默认的props，ES6就是，static defaultProps；接下来就是组件初始化，constructor（props）组件的构造方法；接下来是 componentWillMount组件在加载之前的方法；render完成组件的渲染；componentDidMount 组件渲染完成。接下来就进入运行阶段啦。（一次调用） 组件更新在运行中，如果组件的属性发生了改变，就会调用 componentWillReceiveProps 会被调用，然后就会调用 shouldComponentUpdate ，询问我们是否要渲染组件，如果返回FALSE的话，就不会渲染；如果是TRUE的话，就会调用componentWillUpdate重新渲染组件，然后render，再后来就完成更新啦componentDidUpdate（多次调用） 组件卸载页面关闭的时候，组件会被卸载，componentWillUnmount，可以完成资源的回收与释放啦。（一次调用）]]></content>
      <tags>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作为android小组长，该做什么]]></title>
    <url>%2F2017%2F05%2F15%2Fteam%2F</url>
    <content type="text"><![CDATA[首先，要有一个思想，九品芝麻官也是官，不是让你去摆谱，而是说下面的人会把你但领导看，你必须要有领导的样儿，该站出来是站出来，该严肃是严肃; 统筹协调工作。我们这一期基本只改了UI,没有增加新功能，然后有很多模块类似。这个时候，组长就应该站出来（即使项目开始没意识到，当意识到时应该立马站出来），这个模块统一做一个轮子，大家直接调用即可。 要对整体的框架和功能了如指掌，当领导问你某个模块能否调整，是否会牵扯到其他模块，或者引出其他问题，应该心中有数； 当下属在和产品设计讨论时，讨论过程中，你听明白了，你下属还没明白，不要立马说就是怎么怎么回事，因为你没必要跟下属抢风头，这样反而给下属不好看； 当因为下属没做完或者没做好，导致延期或者加班，对上或者对外要保护自己的下属，恰当的时候，单独找他谈话，也许是工作方式不对，也许是工作能力不行，要对症下药； 时不时的请下属吃个饭，不在于贵贱，而在于心意。当有人要离开，也应该一起吃个饭，我们无法一起工作，但还是可以做朋友的嘛；]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(转) Android IM 开发小结]]></title>
    <url>%2F2017%2F04%2F20%2FAndroid-IM-Summarize%2F</url>
    <content type="text"><![CDATA[客户端架构作为一个 IM 软件，最重要的一个特性就是保证消息的达到率和实时性。达到率受服务器性能和设计协议影响，后面再谈。而实时性则主要取决于客户端进程是否长期存活，连接是否一致保持。由于墙的存在，墙内的 Android 系统是没法用到 GCM 服务的，要实时收到消息推送，就只能靠 App 自己了。也幸好 Android 是一个 “多任务操作系统.真”，我们才能够在墙内也能实时收到微信易信的消息。 进程切分在 Android 系统中，App 对于自己应用的生命周期是基本没有控制力，系统能在任意时候将你的进程杀死，且不会发出任何通知，也会在它认为合适的时候把你叫起来。进程前后台切换也同样不会给出任何通知。不过进程的生死控制也还是有一些规矩的，大体上来说就是进程占的资源越多（内存，CPU 时间等等），对于用户越不重要（前台进程-&gt;可视进程-&gt;服务进程-&gt;后台进程-&gt;空进程），越容易被干掉。因此，进程应当尽量小巧，且具有高的优先级。 如果一个应用本身就很小巧的话，一个进程就完全足够了，主线程负责 UI，另起一个后台线程跑一个服务。而如果应用比较庞大的话，将推送服务独立出来则是一个更好的选择。主进程负责用户交互和主要的业务逻辑，占用庞大的资源，当退到后台后，随时被杀死都无所谓。推送进程则仅仅负责与服务器交互，保持最小限度的业务逻辑处理。网络连接和登录状态是绑在一起的，登录之后，同步数据也是必须的操作。因此，登录和同步数据都需要在推送进程中完成，除此之外，其他的业务都交给 UI 进程处理。推送进程收到自己不属于自己的协议时，就将数据扔给 UI 进程处理。 两个进程之间通信方式没有别的选择，只有 AIDL，难点在于接口的设计。IM 业务逻辑复杂，我们不可能为每一个调用实现一个 AIDL 接口，因此肯定会把接口调用打包成控制命令传递。而标识控制命令比较容易想到的方式，是采用类似于 Message 的 what，由我们为每一个控制命令分配一个命令号（或者再加一个子命令号），并指定对应的命令数据格式，接收端根据命令号再将数据反解出来处理。这种方式比较麻烦，且可维护性很差。更优雅的方式是使用远程过程调用，发送端申明业务的调用接口，并在远端实现这些接口，当发送端调用这些接口时，远端直接调用对应接口的实现。除了使用各种第三方框架外，Java 自身的 Proxy 也能实现这个功能。而从推送进程到 UI 进程还有一点不同，UI 进程随时可能会被干掉，AIDL 调用可能会返回失败，此种情况可选择 Intent 方式传递数据，并兼具唤起 UI 进程的功能。 保活保活分为三个方面，一是系统API提供了接口，应用自己就能做的，这是”合法“的，二是利用系统的缺陷，躲开系统的审查，这算是”非法“的，或者是”灰色“的，三就是多个 App 结盟，互相唤醒，这是耍流氓，谁的阵营庞大谁就赢。 第一种主要有系统闹钟，各种事件的 BroadcastReceiver，任务被移除的回调通知等。 第二种已知的就是在 4.4 及以前版本上，使用 native 进程，并将该进程从 davilk 父进程中脱离，挂接到 init 进程上，以此避开系统的查杀。然后在这个 native 进程中，定时唤起应用。为了让这个 native 进程更轻巧，可以使用 exec 的方式启动一个可执行文件，以除掉直接 fork 带入的 Zygote 进程环境。另外，这种方式也被用在监听自己应用被卸载时弹出调查窗口。 第三种方式现在各大互联网公司都在使用，方式很简单，互相调用指定的 Service，或发指定得广播即可。只要你起一个阿里系的 App，其他阿里系的 App 都会被跟着唤起。你启动一个装了友盟 SDK 的 App， 其他装了友盟 SDK 的 App，以及阿里系的 App 都会被跟着唤醒。 通常，第一种是必备，第二种和第三种则会结伴出现，流氓到底。 网络通信消息的实时性的另一个保证是长连接。当然，你也可以用短连接轮询，但这个一般只在网页端短时聊天使用，在 Android 后台无限时轮询没有人能受的了。长连接类型可以选传统的 TCP，也可以使用 比较新的 WebSocket。 使用后一种的好处主要是服务器的，他们一套连接就可以服务好 App 端和 Web 端。 通信协议选择IM 的通信协议选择性很多，开源的有 XMPP，MQTT等，使用开源协议的优势在于上手快，资料多。而大部分主流 IM 则一般会设计私有的通信协议。使用私有协议，可以针对自己的业务逻辑，设计出更省流量，效率更高的协议，同时，还能有效保护自己的生态圈，就像 Android 手机装不了苹果系统，易信用户不能给微信用户发消息一样。 私有协议的协议内容和开源协议差不多，可以包含通用的协议头，然后加上负载包体。打包时，为了追求可读性，可以使用文本协议，为了追求省流量，则一般使用二进制协议。 在设计私有协议时，消息必达是一个需要侧重考量的地方。由于移动网络的复杂性，消息在客户端和服务器之间传递是有很大可能被传丢的。当客户端发送消息给服务器时，客户端并不能确保消息一定就会被服务器收到，需要服务器在收到消息后给客户端一个回馈，如果客户端没有收到回馈，就需要在一定超时后重新发送。这里存在一个问题就是有可能服务器已经收到了，但回馈的包被丢掉了，这时就会造成消息重复，为了去重，我们需要为相同的消息分配相同的 uuid，供接收方去重。同样，当服务器将消息转发给接收端时，服务器也不能保证接收端就一定能收到，需要接收端给服务器一个回执，告诉服务器这条消息我已经收到了，你就不要再给我发了。 建立安全连接安全性是 IM 软件的另一个硬需求。消息传递时如果通信数据如果被第三方截取，要能保证别人不能获取到真实内容。安全连接的过程可以参考 HTTPS 的方式，由服务器将证书下发给客户端，客户端产生一个对称的密钥，并通过服务器证书加密后交给服务器，之后的通信就全部使用这个对称的密钥来加密。当然，这里有两点需要和 HTTPS 有所区别，第一是证书的获取方式，HTTPS 中是由专门机构去验证证书合法性的，IM 的客户端肯定不会这么去做，为了防止获取证书的过程被人截获，然后篡改证书，可行的方式是直接在客户端安装包中直接把证书打进去，该证书可以随着客户端软件升级一起升级，也可以在加密连接之后通过协议升级。第二个问题是对称加密算法的选择，因为密钥的生命周期是跟随一次连接的，时间并不长，而移动 App 对于电量消耗非常敏感，因此加密算法应尽量选择较为简单的类型，例如 RC4。 心跳心跳可以分为 TCP 的协议层心跳和 App 的应用层心跳。一般我们都使用应用层心跳，一来便于服务器扩展（比如哪天我们可以换成 UDP 来传），二则是可以更灵活控制心跳间隔。心跳协议仅仅是用来连接保活，其内容应当尽量精简，除了包头中必要的部分，包体的可选包头都不存在。对于不同的网络环境，心跳可以采用不同的时间间隔。在不同网络环境下，间隔的选择可以参考微信智能心跳方案。 断线重连客户端掉线的原因无非两种，客户端网络挂了，服务器挂了。客户端网络挂了也分两种，一种是本机就能感知到的网络连接断开，另一种是本机网络是好的，但互联网连接是不同的，对应到 Android API上，就是 NetworkInfo 的 isAvailable 和 isConnected。当然这个地方的 isConnected 不一定可靠，因为它是靠连制定服务器来确定的，那个服务器谁知道有没有问题。 掉线后，根据不同的状态需要选择不同的重连间隔。如果是本地网络出错，并不需要定时去重连，这时只需要监听网络状态，等到网络恢复后重连即可。如果网络变化非常频繁，特别是 App 处在后台运行时，对于重连也可以加上一定的频率控制，在保证一定消息实时性的同时，避免造成过多的电量消耗。 而如果掉线是因为本机网络连不通互联网，或者是服务器挂了，重连间隔的选择就非常重要了。首先，如果程序是在前台，用户正在使用我们的 App，重连间隔应更加频繁，使得用户反馈更加及时，如果程序处于后台运行，则为了省电，可以适当延长重连间隔。其次，随着重连次数的增加，说明服务器短时间内恢复的可能性逐渐降低，重连间隔也应随之延长（倍数增长）。但应该设置一个最大的重连间隔，当到达最大间隔时，不再增加。第三，重连间隔的增加不应当是固定的，而应该增加一个随机退避策略。以免如果是服务器宕机造成掉线，所有客户端的重连时间点都是一样的，当服务器恢复后，同一个时间点所有客户端同时连接服务器，造成服务器不堪拥堵，再次宕机。活生生的例子请参考环信去年的宕机时间。总结起来，重连间隔可表述如下： 12345678int interval(int count) &#123; int maxCount = isForeground() ? MAX_COUNT_FOREGROUND : MAX_COUNT_BAKGROUND; count = Math.min(count, maxCount); int minInterval = BASE * 2^(count - 1); return minInterval + new Random().nextInt(minInterval);&#125; 多媒体数据管理IM 系统中另一个重头戏是多媒体数据。由于移动网络比较慢，流量又贵，在移动端针对这些问题必须要做一些处理。在上传时，尽量减少上传时间，在下载时，能让用户尽快看到内容。同时，尽量节省流量，减少不必要的流量消耗。文本消息因为比较小，可以直接通过长连接传输。但对于多媒体文件，通过长连接来传输则不合适，长连接服务器不会对大文件传输做针对性优化，大量的多媒体文件数据会直接抢占其他信令消息和文本消息的贷款资源。因此，多媒体消息会通过另外的通道，到专门的文件服务器存取。在下载时，对于不同的网络环境，可以采用不同的预取策略。在 WiFi 环境下，由于无需考虑流量问题，在收到消息后，我们就能立即把包含的多媒体文件下载下来。而在移动网络中，则应当等到用户真正看到该多媒体消息时，才去下载。 图片上传时，现在手机摄像头的像素动辄上千万，一张图片随随便便就好几M，然而，通过 IM 软件传输的图片，通常对于质量要求并不会太高，如果我们直接将好几M的图片直接上传，往往费力又不讨好。在上传之前，将图片像素降低，并进行压缩，可以明显的减少上传转菊花的时间，减少用户流量消耗。如果用户确实要求图片质量，则提供一个原图选项。如果是使用 http 上传，大文件会被分成多个数据块上传，前一个数据块传输成功后，再传输下一个。断线重传时，也是以数据块作为最小重传单元。针对不同的网络类型，数据块大小不同。在较好网络下(wifi/4g/3g)，数据块可以比较大，这样可以减少交互时间，加快传输熟读，而在弱网环境，数据块应当设置的比较小，以降低传输失败概率，减少重传流量消耗。使用 http 上传的另一个优化技术是使用 pipeline。在不使用 pipeline 时，上传一个数据块需要等到前一个数据块传输成功才行，数据通道是单工的。使用pipeline则可以将数据通道变为双工的，一个数据块传输完成后，不必等到回包，就能直接上传下一个数据包，能节省一次数据回包延时。 下载时，在消息展示区显示的通常只是一个很小的图片，这时候只需要下载对应大小的缩略图即可，无需下载原图。甚至，这里可以将比缩略图更小的图片二进制数据直接放到消息体中下发，并展示给用户一个高斯模糊后的效果图，在保证最低可用的情况下，减少用户等待时间，提高用户体验。 语言对于不同的网络环境，采取不同质量的语音编码算法，在较好网络时，使用高质量语音，而在弱网环境下，则使用较低质量，优先保证可用性。为了减少用户等待时间，还可以采取边录边传的策略。由于录音时间比较长，在录制的过程中，我们就可以将录好的部分先传到服务器，等到录音完成，只需要上传最后一个数据包，并告知服务器录音完成即可，基本上可以做到录完即传完，无需等待。 语音消息没有缩略图，因此语音下载基本就只能实打实的将原始文件下载下来。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git 常用命令合集]]></title>
    <url>%2F2017%2F03%2F05%2Fgit%2F</url>
    <content type="text"><![CDATA[创建 创建本地仓库： 1git init 获取远程仓库： 1git clone [url] 例：git clone https://github.com/you/yourpro.git 远程 添加一个新的 remote 远程仓库： 1git remote add [remote-name] [url] 例：git remote add origin https://github.com/you/yourpro.git ，origin：相当于该远程仓库的别名 列出所有 remote 的别名： 1git remote 列出所有 remote 的 url： 1git remote -v 删除一个 remote： 1git remote rm [name] 重命名 remote： 1git remote rename [old-name] [new-name] 修改远程仓库地址： 直接修改 1git remote set-url origin [url] 例如：git remote set-url origin https://github.com/you/yourpro.git 先删后加 12git remote rm origingit remote add origin [url] 提交 从本地仓库中添加新的文件： 12git add . // 添加所有文件git add file.txt // 添加指定文件 从本地仓库中删除： 123git rm file.txt // 从版本库中移除，删除文件git rm file.txt -cached // 从版本库中移除，不删除原始文件git rm -r xxx // 从版本库中删除指定文件夹 提交，把内容提交到 HEAD 里： 1git commit -m &quot;注释&quot; 撤销： 1234git revert HEAD // 撤销最近的一个提交git reset --mixed // 取消 commit + addgit reset --soft // 取消 commitgit reset --hard // 取消 commit + add + local working 把本地提交 push 到远程服务器： 12git push [remote-name] [loca-branch]:[remote-branch]例：git push origin master:master 更新代码 查看状态： 1git status 从远程库中下载新的改动-方式1： 1git fetch [remote-name]/[branch] 从远程库中下载新的改动-方式2： 1git pull [remote-name] [branch] 例：git pull origin master pull = fetch + merge 合并下载的改动到分支-方式1： 1234git merge [remote-name]/[branch]解决冲突...git add .git commit -m&apos;fix conflict&apos; 合并下载的改动到分支-方式2： 1234git rebase [remote-name]/[branch]解决冲突...git add .git rebase --continue 分支123456789101112// 列出分支git branch// 创建一个新的分支git branch (branch-name)// 删除一个分支git branch -d (branch-nam)// 删除 remote 的分支git push (remote-name) :(remote-branch)// 切换到一个分支git checkout [branch-name]// 创建并切换到该分支git checkout -b [branch-name] 与github建立ssh通信，让Git操作免去输入密码的繁琐 首先呢，我们先建立ssh密匙。 ssh key must begin with ‘ssh-ed25519’, ‘ssh-rsa’, ‘ssh-dss’, ‘ecdsa-sha2-nistp256’, ‘ecdsa-sha2-nistp384’, or ‘ecdsa-sha2-nistp521’. – from github 根据以上文段我们可以知道github所支持的ssh密匙类型，这里我们创建ssh-rsa密匙。 在command line 中输入以下指令:ssh-keygen -t rsa去创建一个ssh-rsa密匙。如果你并不需要为你的密匙创建密码和修改名字，那么就一路回车就OK，如果你需要，请您自行Google翻译，因为只是英文问题。 $ ssh-keygen -t rsaGenerating public/private rsa key pair.Enter file in which to save the key (/c/Users/Liang Guan Quan/.ssh/id_rsa)您可以根据括号中的路径来判断你的.ssh文件放在了什么地方 到 https://github.com/settings/keys 这个地址中去添加一个新的SSH key，然后把你的xx.pub文件下的内容文本都复制到Key文本域中，然后就可以提交了。 添加完成之后 我们用ssh git@github.com 命令来连通一下github，如果你在response里面看到了你github账号名，那么就说明配置成功了。 let’s enjoy github ;) gitignore在本地仓库根目录创建 .gitignore 文件。Win7 下不能直接创建，可以创建 “.gitignore.” 文件，后面的标点自动被忽略； 1234/.idea // 过滤指定文件夹/fd/* // 忽略根目录下的 /fd/ 目录的全部内容*.iml // 过滤指定的所有文件!.gitignore // 不忽略该文件]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java到底是不是一种纯面向对象语言]]></title>
    <url>%2F2017%2F02%2F23%2Fjava-1%2F</url>
    <content type="text"><![CDATA[Java到底是不是一种纯面向对象语言？静态内容和基本类型它们到底是不是一个对象？下面让我们深入到Java的世界，一步一步证实它！ 旧的认知在我刚开始学习 Java 的时候，我从书本里知道了 Java 是遵循 “面向对象编程范式”的。在Java世界内一切都是对象，甚至包括字符串（String）这些都是对象（在 C 语言中，字符串是字符数组），那时候，我认为 Java是一种面向对象的语言。 但在后来，我在互联网站上陆续看到不少开发者说 “Java实际上不是纯粹的面向对象，因为并不是所有的东西在 Java 世界都是一个对象”。 他们很多的论点都可以概括为以下两点： 所有的静态内容（ static 关键修饰的变量和方法）不属于任何对象，所以这些是非对象的东西。 所有基本类型（char，boolean，byte，short，int，long，float，double）都不是对象，因为我们不能做类似正常对象的所具有的操作（例如：使用“.”来访问对象的属性和方法）。 在那时，由于个人知识经验储备有限，我又很容地相信上面的论点，并且也开始认为 “Java 不是纯粹的面向对象编程语言”。 新的发现JVM 在创建对象的时候，实际上会创建两个对象： 一个是实例对象 另一个是Class 对象。该 Class 对象在JVM内仅仅会装载一次，该类的静态方法和静态属性也一同装载，JVM使用该 Class 对象来创建具体的实例对象（如上面的对象）。 例如，在下面的 Java 语句中，将有两个对象被创建： 1Employee emp = new Employee(); 一个是实例对象 emp ；另一个则是 Class对象，我们可以通过 Employee.class 引用到它；这个 Class 对象拥有所有的这个类定义的静态变量和静态方法，同时，如果我们访问 通过 emp 对象来访问静态内容，会发现它其实指向的对象就是 Employee.class . 这也揭开了另一个迷：为什么静态内容在一个对象中（不管是emp还是emp2）改变了，在另一个对象中也同时改变，因为这两个对象改变的都是在 Employee.class 同一个对象里面的内容。 现在，上面说到的第一个论点我们要取消了。因为，静态内容确实被证实属于一个对象。 但是我们还要确认第二个论点：正如早前提到的，原始类型在Java中不是对象，它们无法做类似对象的操作。为了解决这个问题，Java 官方为每一个原始类型推出了对应的包装类（比如：Integer 对应 int，Long 对应 long，Character 对应 char），所以，其实现在我们可以为原始类型创建一个包装对象，同时对它们做对象相关的操作。并且，由于自动拆装箱，我们可以把一个原始类型值赋值给它对应的包装类的引用。但是我们仍然不能对这些原始类型做对象的操作——我们需要创建对应包装类的对象。 例如： 12Integer obj = new Integer(5); // here we can do i.toString();int i = 5; // but we can't do i.toString() here 到目前为止，从一个最终用户的角度上来看的，我们可以确认 “原始类别不是对象”。（ Java开发人员是Java的最终用户，因为我们正在使用它，而不是创造它 ）。 如果站在JVM的视角，会有新的发现： 其实，在JVM看来它把所有的 “原始类型” 都是当作对象处理” ，要证明这一点可以通过 Class类的源代码 或者 Javadoc中Class类的说明。 根据 java.lang.Class 类的源代码，该类的注释是： Java官方描述： Instances of the class Class represent classes and interfaces in a running Java application. An enum is a kind of class and an annotation is a kind of interface. Every array also belongs to a class that is reflected as a Class object that is shared by all arrays with the same element type and number of dimensions. The primitive Java types (boolean, byte, char, short, int, long, float, and double), and the keyword void are also represented as Class objects. 参考译文： Class类的实例表示正在运行的Java应用程序的类和接口。像枚举是一种类,注解则是一种接口。每个数组也属于被反射作为由具有相同的元素类型和尺寸的数目的所有阵列共享一类对象的类。原始的Java类型（boolean, byte, char, short, int, long, float, and double）和关键字void也表示为Class对象。 同时也根据Javadoc中对Class.isPrimitive()方法的定义，来判断 Java官方描述： public boolean isPrimitive()Determines if the specified Class object represents a primitive type.There are nine predefined Class objects to represent the eight primitive types and void. These are created by the Java Virtual Machine, and have the same names as t he primitive types that they represent, namely boolean,byte, char, short, int, long, float, and double.These objects may only be accessed via the following public static final variables, and are the only Class objects for which this method returns true.Returns:true if and only if this class represents a primitive typeSince:JDK1.1 参考翻译： public boolean isPrimitive()判断指定的Class对象是否代表一个基本类型。一共有9种设定好的Class对象来表示对应的基本类型和void关键字。这些对象都是由JVM创建的。…return当且仅当该类表示一个真正的基本类型 以上都说明，在JVM内部，其实原始类型就是对象。当你打开 Javadoc 对 Class 类的定义中，通过 “CTRL＋F ” 查找关键字 “primitive”， 将会发现证据在表面 “在JVM里，它把基本类型当作对象来处理的”。我们可以再来看一个例子： Integer.TYPE，在这部分文档清晰记录着：Java官方描述： public static final Class TYPEThe Class instance representing the primitive type int. 以上都说明，在JVM内部，其实原始类型就是对象。 那么，既然说 “JVM”会为所有的基本类型创建一个对象，那我们为什么还那么常用 “原始类型”， 而不是直接使用对应的包装类对象呢？ 这是因为，为 “原始类型” 创建的对象，在JVM内部是很轻量级的，相对与我们直接创建的对应包装类对象做了许多优化； 也正因为轻量的缘故，这些原始类的功能就比较少（例如我们不能调用其内部的方法，因为他们内部已经优化成没有方法了） 使用实际的例子来说明，为什么我们更应该使用 “原始类型”： “原始类型”有更快的速度（例如，下面的代码执行，在我们的机器上需要9秒，但当我把 Long 改成 long 之后，0秒内就完成了） 123456789public static void main(String[] args) &#123; long millis = System.currentTimeMillis(); Long sum = 0L; // uses Long, not long for (long i = 0; i &lt;= Integer.MAX_VALUE; i++) &#123; sum += i; &#125; System.out.println(sum); System.out.println((System.currentTimeMillis() - millis) / 1000);&#125; “原始类型”允许我们直接使用 “==”来进行比较 1234new Integer(3) == new Integer(3); // falsenew Integer(100) == new Integer(100); // falseInteger.valueOf(5) == Integer.valueOf(5); //trueInteger.valueOf(200) == Integer.valueOf(200); //false 我们注意看第四句，输出结果确实为 “false” 。这个是因在 [-128; 127] 这个区间的265个整数会被 JVM 缓存存放， 所以在这个区间， JVM返回相同的对象；然而，超出这个区间， JVM就不再有缓存了，将会创建新的对象，所以结果是不等的。 所以总结一下是： 在JVM内部，原始类型就是被当作对象来处理的。但是我们开发者直接把 “原始类型” 当作对象使用，开发者应该使用对应的包装来。 以上就证实了Java确实是一个纯粹的面向对象语言]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android快速发布项目到jcenter]]></title>
    <url>%2F2017%2F02%2F14%2Frelease-JCenter%2F</url>
    <content type="text"><![CDATA[最近在整理项目的时候，想要上传至Jcenter，可以让大家一句代码就可以引入。就在网上寻找，然而网上有些方法实在是太麻烦，故写此篇文章将心酸历程写下，让各位老司机少走弯路，快速发布 注册Bintray账号个人注册 Bintray 地址：https://bintray.com/signup/oss不要去 https://bintray.com/login 注册，这个千万不能搞错。注意一下邮箱问题：不能用QQ，163等，推荐用Gmail，国内用户可以使用github的账号进行登陆完成注册，也要注意邮箱问题。 获取信息：登陆后在首页右上角点击用户名进入个人主页，然后点击用户名下面的Edit Profile进入个人信息编辑页面，接下来点击页面左边列表的最后一项API Key，保存下来，因为将项目发布到JCenter时会用到它。 Add New Repository注册完之后，第一件事情是”Add New Repository”。 点击之后就是创建Repository了，记得下图中红框的位置一定要填小写的maven，否则无法发布上去: Repository创建完之后，我们就可以正式进入发布项目之旅了。 Android项目的发布步骤1. 修改根目录下build.gradle先添加12345678buildscript &#123; ... dependencies &#123; ... classpath 'com.novoda:bintray-release:+' &#125;&#125; 以及123456789101112allprojects &#123; repositories &#123; jcenter() &#125; //加上这些 tasks.withType(Javadoc) &#123; options&#123; encoding "UTF-8" charSet 'UTF-8' links "http://docs.oracle.com/javase/7/docs/api" &#125; &#125;&#125; 2.对需要发布的module，修改build.gradle先添加插件1apply plugin: 'com.novoda.bintray-release' 再加上publish 123456789101112131415161718192021allprojects &#123; repositories &#123; jcenter() &#125; //加上这些 tasks.withType(Javadoc) &#123; options&#123; encoding "UTF-8" charSet 'UTF-8' links "http://docs.oracle.com/javase/7/docs/api" &#125; &#125;&#125;publish&#123; userOrg = 'zchu' // Bintray 账号名 groupId = 'com.zchu' artifactId = 'zlog' publishVersion = '1.0.0' desc = 'This is a log print library for android' website = 'https://github.com/z-chu/ZLog' //github 地址&#125; 假如 JCenter 审核通过，就可以用多种方式添加该库了。使用gradle添加该库：1compile 'com.zchu:zlog:1.0.0' 使用maven添加该库：123456&lt;dependency&gt; &lt;groupId&gt;com.zchu&lt;/groupId&gt; &lt;artifactId&gt;zlog&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; 3. 发布执行下面的语句 ./gradlew clean build bintrayUpload -PbintrayUser={Bintray的用户名} -PbintrayKey={API Key} -PdryRun=false 但是，我相信绝大多数人都会遇到BUILD FAILED 的情况的。打包过程遇到的错误大致总结一下就是 1Javadoc generation failed. Generated Javadoc options file (useful for troubleshooting): ‘路径’ 错误: 编码GBK的不可映射字符 ——注释不要用中文，或者修改项目的字符编码 错误: 编码GBK的不可映射字符 ——注释不要用中文，或者修改项目的字符编码 1Could not create package ‘路径’: HTTP/1.1 401 Unauthorized [message:This resource requires authentication] 你一定是用户名或者APIKey填错了。 4.发布完之后不是执行完上述的语句就算完了，还需要通过 JCenter 的审核。 当然不通过审核也是可以使用的，在根目录的build.gradle中添加形如下面的脚本123456allprojects &#123; repositories &#123; jcenter() maven&#123;url 'https://dl.bintray.com/zchu/maven/'&#125; &#125;&#125; 最为重要的是下面这一句，但是通过审核的话完全不需要添加这一句。 1maven&#123;url 'https://dl.bintray.com/zchu/maven/'&#125; 所以，我们需要通过JCenter审核，否则没有意义。 5.审核通过JCenter 会通过邮件和站内消息的形式通知到你，一般情况是几个小时之后，审核通过后，就可以尽情地在项目中使用了。 6.版本更新发布新版本时，必须修改publish的publishVersion且高于原先的版本号。如果publishVersion已经存在，上传时会报错并给出如下类似的提示,除非删除原来的版本。12345678* What went wrong:Execution failed for task &apos;:saf-aop:bintrayUpload&apos;.&gt; Could not upload to &apos;https://api.bintray.com/content/fengzhizi715/maven/saf-aop/1.0.0/com/safframework/saf-aop/1.0.0/saf-aop-1.0.0-sources.jar&apos;: HTTP/1.1 409 Conflict [message:Unable to upload files: An artifact with the path &apos;com/safframework/saf-aop/1.0.0/saf-aop-1.0.0-sources.jar&apos; already exists]* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.BUILD FAILED 上传完成后，点击下图按钮即可。 更新的审核比较快，稍等一下就行了。 好了，教程到此结束了，是不是 so easy !呢？？？]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RecycleView4种定位滚动方式演示]]></title>
    <url>%2F2017%2F02%2F11%2FRecyclerView-Scroll%2F</url>
    <content type="text"><![CDATA[概述相信大家在项目中使用RecyclerView时，经常会遇到这样的需求：将RecyclerView滑动到指定位置，或者检索RecyclerView的某一项（各个项的高度不确定），然后定位滚动这到一项，将它显示。 下面就讲解4种RecyclerView定位滚动的方式及具体效果演示。 scrollBy 使用：recyclerView.scrollBy(x, y) scrollBy(x, y)这个方法是自己去控制移动的距离，单位是像素,所以在使用scrollBy(x, y)需要自己去计算移动的高度或宽度。 scrollToPosition 使用： recyclerView.scrollToPosition(position) scrollToPosition(position)这个方法的作用是定位到指定项，就是把你想显示的项显示出来，但是在屏幕的什么位置是不管的，只要那一项现在看得到了，那它就罢工了！ smoothScrollToPosition 使用： recyclerView.smoothScrollToPosition(position) smoothScrollToPosition(position)和scrollToPosition(position)效果基本相似，也是把你想显示的项显示出来，只要那一项现在看得到了，那它就罢工了，不同的是smoothScrollToPosition是平滑到你想显示的项，而scrollToPosition是直接定位显示！ scrollToPositionWithOffset 使用： ((LinearLayoutManager)recyclerView.getLayoutManager()).scrollToPositionWithOffset(position,0); 主角总是最后才登场，这种方式是定位到指定项如果该项可以置顶就将其置顶显示。比如:微信联系人的字母索引定位就是采用这种方式实现。 资源下载apk下载 Github 其他资料Android RecyclerView滚动定位 RecyclerView调用smoothScrollToPosition() 控制滑动速度 RecyclerView使用技巧-自动滚动 如何获取 RecyclerView 的滑动距离？ RecyclerView滚动到指定位置]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RecycleView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈设计模式之单例模式]]></title>
    <url>%2F2017%2F02%2F09%2Fsingleton-pattern%2F</url>
    <content type="text"><![CDATA[当我们有这样的需求:某一些类应该只存在一个实例 的时候,我们就可以用单例模式来应对. 单例模式是所有设计模式中最简单的一个,也是大部分人最早知道的一个设计模式. 但是即使是最简单的,也有很多可以推敲的细节,要做得对也不简单. 经典的单例相信大家一定写过这样类似的单例模式代码: 1234567891011public class Singleton &#123; private static Singleton instance; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (null == instance) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 简单总结一下这样的写法: 提供一个全局静态的getInstance方法,使得易于使用. 延迟Singleton的实例化,节省资源(所谓的懒汉式). 缺点是线程不安全.当多个线程同时进入if (null == instance) {}的时候就会创建多个实例. OK,接下来我们看来是要解决多线程不安全的问题了. 多线程安全这个时候可能有的人就说了,这个太简单了,加一个synchronized不就结了吗? 123456public static synchronized Singleton getInstance() &#123; if (null == instance) &#123; instance = new Singleton(); &#125; return instance;&#125; 确实,增加synchronized之后能够迫使每个线程在进入这个方法之前,要先等别的线程离开该方法.也即避免了多个线程同时进入getInstance方法. 诚然这个能解决问题,但是我们知道synchronized是非常耗性能的. 更何况:我们只需要在第一次执行这个方法的时候同步,也就是说当instance实例化后,我们不再需要同步了而如果我们加了synchronized,那么实例化后的每次调用getInstance都是一种多余的消耗操作,是累赘 当然,如果哪些额外的负担你能接受(比如用的很少),那么添加synchronized的方法也是可以接受的,毕竟这是最简单的方式. 那么问题来了,如何改善?如何确保单例,而又不影响性能? 性能进阶接下去介绍一种更优秀的,线程安全的单例写法—双重检查锁模式(double check locking pattern) 123456789101112131415public class DoubleCheck &#123; private volatile static DoubleCheck instance; private DoubleCheck() &#123;&#125; public static DoubleCheck getInstance() &#123; if (null==instance)&#123; //检查 synchronized (DoubleCheck.class)&#123; if (null == instance) &#123; //又检查一次 instance = new DoubleCheck(); &#125; &#125; &#125; return instance; &#125;&#125; 注意这里的instance用了volatile关键字来修饰,为什么呢?因为执行instance = new DoubleCheck()做了很多事情: 给instance分配内存 调用构造函数来初始化成员变量(可能会很久) 将ins对象指向分配的内存空间（执行完这步 ins才不为null） 上面的操作并不是原子操作,而jvm也可能重排序指令,导致第二三两步的执行顺序可能会被打乱,当第3步先于第2步完成,那么会导致有线程拿到了初始化未完毕的instance,那么就会错误,而这里利用了volatile的禁止指令重排序优化特性,用来解决这个问题. 注:volatile 在java 5 后才有效,原因是 Java 5 以前的 Java 内存模型是存在缺陷的,当然现在不需要担心这个啦! 小结 双重检查非常适用于高并发,我们熟知的开源库EventBus,Glide等都是用的双重检查锁方式实现单例 不过它,写起来稍微复杂了些,有没有简单点的呢?答案是:有! 饿汉式直接上代码吧 123456public class Early &#123; private static final Early instance = new Early(); public static Early getInstance() &#123; return instance; &#125;&#125; 饿汉式的原理其实是基于classLoader机制来避免了多线程的同步问题 饿汉式与之前提到的懒汉式不同,它在我们调用getInstance之前就实例化了(在类加载的时候就实例化了),所以不是一个懒加载,这样就有几个缺点: 延长了类加载时间 如果没用到这个类,就浪费了资源(加载了但是没用它) 不能传递参数(很显然适用的场景会减少) 静态内部类静态内部类原理同上,另外虽然它看上去有点恶汉式,但是与之前的恶汉有点不同,它在类Singleton加载完毕后并没有实例化,而是当调用getInstance去加载Holder的时候才会实例化,静态内部类的方式把实例化延迟到了内部类的加载中去了!所以它比饿汉式更优秀!(偷偷告诉你《Effective Java》中也推荐这个方式) 123456789public class Singleton &#123; private static class Holder&#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getInstance()&#123; return Holder.INSTANCE; &#125;&#125; 枚举最后介绍一种,也是我在《Effective Java》中看到的,居然用枚举!!! 123public enum Singleton&#123; INSTANCE;&#125; 看上去好牛逼，通过Singleton.INSTANCE来访问，这比调用getInstance()方法简单多了。这种方式是《Effective Java》作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊。 默认枚举实例的创建是线程安全的，所以不需要担心线程安全的问题。但是在枚举中的其他任何方法的线程安全由程序员自己负责。还有防止上面的通过反射机制调用私用构造器。 这个版本基本上消除了绝大多数的问题。代码也非常简单，实在无法不用。 总结单例模式（Singleton）会控制其实例对象的数量，从而确保访问对象的唯一性。 单例模式的优点 实例控制：单例模式防止其它对象对自己的实例化，确保所有的对象都访问一个实例。 伸缩性：因为由类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。 单例模式的缺点 系统开销。虽然这个系统开销看起来很小，但是每次引用这个类实例的时候都要进行实例是否存在的检查。这个问题可以通过静态实例来解决。 开发混淆。当使用一个单例模式的对象的时候（特别是定义在类库中的），开发人员必须要记住不能使用new关键字来实例化对象。因为开发者看不到在类库中的源代码，所以当他们发现不能实例化一个类的时候会很惊讶。 对象生命周期。单例模式没有提出对象的销毁。在提供内存管理的开发语言（比如，基于.NetFramework的语言）中，只有单例模式对象自己才能将对象实例销毁，因为只有它拥有对实例的引用。在各种开发语言中，比如C++，其它类可以销毁对象实例，但是这么做将导致单例类内部的指针指向不明。 单例适用性使用Singleton模式有一个必要条件：在一个系统要求一个类只有一个实例时才应当使用单例模式。反之，如果一个类可以有几个实例共存，就不要使用单例模式。 不要使用单例模式存取全局变量。这违背了单例模式的用意，最好放到对应类的静态成员中。 不要将数据库连接做成单例，因为一个系统可能会与数据库有多个连接，并且在有连接池的情况下，应当尽可能及时释放连接。Singleton模式由于使用静态成员存储类实例，所以可能会造成资源无法及时释放，带来问题。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式概览]]></title>
    <url>%2F2017%2F02%2F08%2FDesign-patterns-2%2F</url>
    <content type="text"><![CDATA[1.定义 某类特定问题的代码设计解决方案 是一套代码设计的经验总结 设计模式，其实只是前人针对某类问题的代码设计经验而已，并没有很高大上 2.作用 提高代码复用率，降低开发成本和周期 提高代码可维护性、可拓展性 使代码更加优雅 让代码更容易被他人理解 3.七大设计原则 开闭原则一个实体（类、函数、模块等）应该对外扩展开放，对内修改关闭 简单的说就是，别人可以基于你的代码进行拓展编写，但却不能修改你的代码。反过来说就是，你在写代码时就要考虑到：怎么让别人可以不修改你的代码，就能对你的代码进行扩展。 开闭原则是面向对象设计中“可复用设计”的基石，是面向对象设计中最重要的原则之一，其他原则都可以看作是开闭原则的实现方法。 即每次发生变化时，要通过添加新的代码来增强现有类型的行为，而不是修改原有的代码。 符合开放封闭原则的最好方式是提供一个固有的接口，然后让所有可能发生变化的类实现该接口，让固定的接口与相关对象进行交互。 单一职责原则一个类应该只能有一个引起它变化的原因。 一个类，只有一个引起它变化的原因。应该只有一个职责。每一个职责都是变化的一个轴线，如果一个类有一个以上的职责，这些职责就耦合在了一起。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。例如：要实现逻辑和界面的分离。 里氏代替原则任何基类可以出现的地方，子类一定可以出现。子类可以扩展父类的功能，但不能改变父类原有的功能。 在软件开发过程中，子类替换父类后，程序的表现行为是一样的。 只有当子类替换掉父类后软件的功能不受影响时，父类才能真正地被复用，而子类也可以在父类的基础上添加新的行为。 依赖倒置原则程序要依赖于抽象接口，不要依赖于具体实现。简单的说就面向抽象进行编程，不要面向实现进行编程，这样就降低了客户与实现模块间的耦合。 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。 抽象不应该依赖于具体，具体应该依赖于抽象。 接口隔离原则程序不应该依赖它不需要的接口。一个类对另一个类的依赖应该建立在最小的接口上。 使用多个专门的接口比使用单一的总接口要好。一个类对另外一个类的依赖性应当是建立在最小的接口上的。一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。 合成复用原则在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分。 新对象通过向这些对象的委派达到复用已用功能的目的。简单地说，就是要尽量使用合成/聚合，尽量不要使用继承。 最少知识原则（迪米特法则）一个模块或对象应尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立，这样当一个模块修改时，影响的模块就会越少，扩展起来更加容易。 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。关于迪米特法则的其他描述：只与你直接的朋友们通信；不要跟“陌生人”说话。 4.七大设计原则分3大类，共23种设计模式.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象基础]]></title>
    <url>%2F2017%2F02%2F07%2FDesign-patterns-1%2F</url>
    <content type="text"><![CDATA[一个面向对象的程序（ OOP ）实际上就是一个相对去中心化、模块化的程序。对于一个 OOP 来说，它的一个 “ 碎片 “ ，就是一个独立成立、保持自身完整性的单元；它可以和其他的 OOP” 碎片 “ 整合在一起形成一个可分解的指令结构。“ 对象 “ 限制了程序漏洞所能造成的损害，有效地对功能实行了隔离，把每个功能都限制在一个可掌控的单元内，这样一来，即使一个对象崩溃了，程序的其他部分也能够继续运转。程序员可以把这个坏掉的单元换掉，就好像我们可以给一个汽车换刹车片一样。再比如：我们做的 app ，它有许多的功能，每一个功能它对应一个模块。我们通过一个一个实现再把这些模块堆起来，通过我们的接口、方法、回调等把它们组合起来，最后形成我们的面向对象程序，也就是最后生成了我们的 app .模块自身应该是单一的、高内聚的，模块与模块之间应该是低耦合的 面向对象三大特征JAVA面向对象最重要的特征就是：封装，继承，多态(所谓的三大特征)。以下就个人体会来简单讲一下. 封装封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。该逻辑单元负责将所描述的属性隐藏起来，外界对客体内部属性的所有访问只能通过提供的用户接口实现。 优点 封装就是隐藏实现细节。使用者只需要关注怎么用，而不需要关注内部是怎么实现的。实现细节可以随时修改，而不影响使用者。 抽取可复用的逻辑单元,统一处理,提高效率。 缺点过度封装会不利于程序扩展，可变性降低. 继承继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力.Java继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。 优点代码重用：子类继承父类后拥有父类的属性成员,可以很好的复用已有的类,不需要再重复写方法属性. 缺点 如果继承很重,那么子类不管要不要，有没有用，都会拥有父类的所有东西，影响子类性能造成代码冗余. 继承可能破坏封装：因为子类和父类之间可能存在着实现细节的依赖.子类在继承父类的时候，往往不得不关注父类的实现细节，而父类在修改其内部实现的时候，如果不考虑子类，也往往会影响到子类. 多态多态的作用，就是把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化. 多态在设计模式中扮演着非常非常重要的角色.策略模式,里氏替换原则等就是多态的特性的最好阐述. 优点 消除类型之间的耦合关系. 可实现动态绑定,增加可扩展性. 缺点会使代码可读性变差，在定位代码的时候比较麻烦,需要去寻找具体的实现类。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开闭原则]]></title>
    <url>%2F2017%2F01%2F23%2FOpenClosedPrinciple%2F</url>
    <content type="text"><![CDATA[面向扩展开放，面向修改关闭。简单的说就是，别人可以基于你的代码进行拓展编写，但却不能修改你的代码 开闭原则（OCP）是面向对象设计中“可复用设计”的基石，是面向对象设计七大原则之一，也是面向对象设计中最重要的原则之一，实际上里氏替换原则（LSP）、依赖倒转原则（DIP）、接口隔离原则（ISP）以及抽象类（Abstract Class）、接口(Interface)等等，都可以看作是开闭原则的实现方法。 面向扩展开放，面向修改关闭 对于扩展是开放的（Open for extension）。这意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。也就是说，我们可以改变模块的功能。 对于修改是关闭的（Closed for modification）。对模块行为进行扩展时，不必改动模块的源代码。相对的在设计时就应考虑到，不需要改动模块的源代码，就可以对模块进行扩展。 开闭原则的相对性软件系统的构建是一个需要不断重构的过程，在这个过程中，模块的功能抽象，模块与模块间的关系，都不会从一开始就非常清晰明了，所以构建100%满足开闭原则的软件系统是相当困难的，这就是开闭原则的相对性。但在设计过程中，通过对模块功能的抽象（接口定义），模块之间的关系的抽象（通过接口调用），抽象与实现的分离（面向接口的程序设计）等，可以尽量接近满足开闭原则。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我对MVC和MVP的一些理解]]></title>
    <url>%2F2017%2F01%2F21%2Farchitecture1%2F</url>
    <content type="text"><![CDATA[MVCMVC是软件架构中最常见的一种框架,简单来说就是通过controller的控制去操作model层的数据，并且返回给view层展示.比如当用户出发事件的时候，view层会发送指令到controller层，接着controller去通知model层更新数据，model层更新完数据以后直接显示在view层上，这就是MVC的工作原理。 那具体到Android上是怎么样一个情况呢？对于原生的Android项目来说，layout.xml里面的xml文件就对应于MVC的view层，里面都是一些view的布局代码，而各种java bean，还有一些数据相关的类就对应于model层，至于controller层嘛，当然就是各种activity咯。 举个例子:比如你的界面有一个按钮，按下这个按钮去网络上下载一个文件.这个按钮是view层的，是使用xml来写的.这个下载文件的工作,你可以写一个专门的下载器,这个就是model层. 那怎么连接这两层呢？当然是在activity通过给这个按钮设置点击事件的监听,在响应点击事件时去启动这个下载器，这就对应于controller层. 问题就在于xml作为view层，控制能力实在太弱了，你想去动态的改变一个页面的背景，或者动态的隐藏/显示一个按钮，必须要获得这个view 对象去操控,这些都没办法在xml中做，只能把代码写在activity中，造成了activity既是controller层，又是view层的这样一个窘境。如果是一个逻辑很复杂的页面，activity或者fragment是不是动辄上千行呢？这样不仅写起来麻烦，维护起来更是噩梦。MVC还有一个重要的缺陷，view层和model层是相互可知的，这意味着两层之间存在耦合. MVPMVP作为MVC的演化，解决了MVC不少的缺点. 对于Android来说，MVP的model层相对于MVC是一样的,而activity和fragment不再是controller层，而是纯粹的view层，所有关于用户事件的转发全部交由presenter层处理。 与MVC最明显的差别就是view层和model层不再相互可知，完全的解耦，MVC中View会直接从Model中读取数据而不是通过 Controller。取而代之的presenter层充当了桥梁的作用，用于操作view层发出的事件传递到presenter层中，presenter层去操作model层，并且将数据返回给view层，整个过程中view层和model层完全没有联系。 看到这里大家可能会问，虽然view层和model层解耦了，但是view层和presenter层不是耦合在一起了吗？其实不是的，对于view层和presenter层的通信，我们是可以通过接口实现的，具体的意思就是说我们的activity，fragment可以去实现实现定义好的接口，而在对应的presenter中通过接口调用方法。不仅如此，我们还可以编写测试用的View，模拟用户的各种操作，从而实现对Presenter的测试。 这就解决了MVC模式中测试，维护难的问题。具体来说，如果你需要测试一个http请求是否顺利，你不需要写一个activity，只需要写一个java类，实现对应的接口，presenter获取了数据自然会调用相应的方法，相应的，你也可以自己在presenter中模仿数据，分发给view层，用来测试布局是否正确。 MVP的问题在于，由于我们使用了接口的方式去连接view层和presenter层，这样就导致了一个问题，如果你有一个逻辑很复杂的页面，你的接口会有很多，十几二十个都不足为奇。想象一个app中有很多个这样复杂的页面，维护接口的成本就会非常的大。 这个问题的解决方案就是你得根据自己的业务逻辑去斟酌着写接口。你可以定义一些基类接口，把一些公共的逻辑，比如网络请求成功失败，toast等等放在里面，之后你再定义新的接口的时候可以继承自那些基类，这样会好不少。 MVP的优点 降低耦合度，隐藏数据，Activity中代码更简洁 模块职责划分明显 方便测试驱动开发 代码复用度较高 代码灵活性 总结从MVC到MVP的一个转变，就是减少了Activity的职责，减轻了它的负担，简化了Activity中的代码和一些操作，将逻辑代码提取到了Presenter中进行处理，降低了其耦合度。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[原型模式]]></title>
    <url>%2F2017%2F01%2F21%2Fprototype-pattern%2F</url>
    <content type="text"><![CDATA[模式的定义用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。 模式的使用场景 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等，通过原型拷贝避免这些消耗； 通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式； 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝。 Android源码中的模式实现Intent中使用了原型模式 Uri uri = Uri.parse("smsto:0800000123"); Intent shareIntent = new Intent(Intent.ACTION_SENDTO, uri); shareIntent.putExtra("sms_body", "The SMS text"); Intent intent = (Intent)shareIntent.clone() ; startActivity(intent); 优点与缺点优点原型模式是在内存二进制流的拷贝，要比直接 new 一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。 缺点这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的，在实际开发当中应该注意这个潜在的问题。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android面试之性能优化]]></title>
    <url>%2F2017%2F01%2F21%2FAndroid-interview3%2F</url>
    <content type="text"><![CDATA[性能优化 界面不流程，如何去debug调试View，来定位卡顿问题？ 如何解决卡顿问题？ xml编写和View写法是否合理？ 移除不必要的背景图 window默认背景图 ListView设置背景后，item又设置了背景图 多层嵌套，多次设置背景图 优化布局避免空间View树过高，空间重叠 自定义View的时候使用clipRect裁剪出需要绘制的区域绘制，已减少其他区域的绘制。 可以通过Android SDK提供的Hierarchy View可量化的子View的总是和测量（measure）、布局（layout）、绘制（draw）所消耗的时间，以及View层级树的高度 首先要明白的是UI的绘制流程：measure-layout-draw，measure与layout都需要for loop所有的子控件，汇集起来才能完成绘制，布局。所以子控件越多，所消耗的时间越长(inflate，layout_weight，relative，多层嵌套等)，减少不必要的子控件或层级，是相当有必要的。你可以通过merge,viewstub这些标签来减少层级嵌套。如果你的空间观念没那么好，可以用HierarchyViewer工具来检查。 Mesure过程 设置本View视图的最终大小 如果该View对象是个ViewGroup类型，需要重写该onMeasure()方法，对其子视图进行遍历的measure()过程。 measureChilren(),内部使用一个for循环对子视图进行遍历，分别调用子视图的measure()方法 measureChlid()，为指定的子视图measure，会被measureChildren调用 measureChildWithMargins(),为指定子视图考虑了margin和padding的measure。 Layout过程 layout方法会设置该View视图位于父视图的坐标轴，即mLeft,mTop,mRight，mBottom(调用setFrame()函数去实现） 接下来回调onLayout()方法（如果该View是ViewGroup对象，需要实现该方法，对每个子视图进行布局） 如果该View是个ViewGroup类型，需要遍历每个子视图的childView，调用该子视图的layout()方法去设置它的坐标值 帧率 在安卓中界面要看起来流畅，那么它的帧率是60，也就是说在1秒钟之内它会刷新60次，那么每次刷新的耗时也就是1000ms除了60，等于16.67ms. 那么如果视图的刷新时间在16ms之内完成了，我们用起来就会觉得很流畅，那么假如因为某种原因，一个刷新过程没有在16ms之内完成，那么就会出现掉帧现象，也就是卡顿了。那么为了不出现这种掉帧现象，让用户用起来更流程，就需要尽量让一个绘制过程在16ms只能完成。 这也就是性能优化所要最终完成的目标。Measure+Layout+Draw&lt;=16ms. 那么我们就只要看measure、layout、draw都干了那些事情，有哪些点是可以优化的，只要逐个的解决这些优化点，也就完成了一系列的View优化工作。 如何优化从内优化（从View本身） 尽可能少的使用margin,padding因为在测量绘制的过程中，会单独对已经设置过margin和padding的View进行另外多一步的操作，所有这个时候可以采用在父View中设置margin和padding来代替在子View中进行分别设置 减少View层级这3个过程都涉及到循环遍历子View的过程，所有减少View的层级可以很好的加快循环遍历的过程 去除不必要的背景 去除不必要的scrollbar和不需要的效果 慎用渐变 从外优化 布局嵌套过于复杂这个会直接导致View的层级变多，然后测量绘制的效率变差 View的过度绘制 View的频繁重新渲染 UI线程中进行耗时操作 在Android4.0其实是不允许ui线程中做网络操作了，那假如说你不小心做了写IO操作，而且他们又比较耗时，有可能会导致UI线程卡顿。View绘制阻塞 冗余资源及错误逻辑导致加载和执行缓慢（其实就代码写的烂）比如你在getView()里去for循环，for循环里又for循环，又去声明变量之类的，都会导致代码的执行效率很差 频繁触发GC,导致渲染受阻GC线程优先级高于UI线程，所有如果内存管理不够合理的话频繁的触发了GC,就会导致UI线程的受阻]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android面试之网络]]></title>
    <url>%2F2017%2F01%2F21%2FAndroid-interview2%2F</url>
    <content type="text"><![CDATA[TCP/IP、HTTP、Socket的区别网络由下往上分为： 物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。 我们知道IP协议对应网络层，TCP协议对应于传输层，而HTTP协议对应于应用层。 三者从本质上来说没有可比性， Socket则是对TCP/IP协议的封装和应用(程序员层面上)。 也可以说，TCP/IP协议是传输层协议，主要解决数据如何在网络中传输， 而HTTP是应用层协议，主要解决如何包装数据。 关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：我们在传输数据时，可以只使用(传输层)TCP/IP协议。但那样的话，没有了应用层，便无法识别数据内容。 如果想要是传输的数据有意义，则必须使用到应用层协议。 应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。 web使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。 而我们平时说的最多的Socket是什么呢，实际上Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API）。 通过Socket,我们才能使用TCP/IP协议。 实际上，Socket跟TCP/IP协议没有必然的联系。 SoCket编程接口在设计的时候，级希望也能适应其他的网络协议。 所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象， 从而形成了我们知道的一些最基本的函数接口，比如create、listen、connect、accept、send、read和write等等。 网络有一段关于socket和TCP/IP协议关系的说法比较容易理解： TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还有提供对外的操作接口。 这个就像操作系统会提供标准的编程接口，比如win32编程接口一样， TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。 CSDN上有个比较现象的描述：HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。 实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。 什么是TCP连接的三次握手第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k）,即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1),此包发送完毕，客户端和服务器进入ESTABLISHED（确认连接）状态，完成三次握手。 握手过程中传送的包含数据，三次握手完成后，客户端和服务器才正式开始传送数据。 理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android面试之java基础]]></title>
    <url>%2F2017%2F01%2F21%2FAndroid-interview1%2F</url>
    <content type="text"><![CDATA[面向对象 一个面向对象的程序（OOP）实际上就是一个相对去中心化、模块化的程序。 对于一个OOP来说，它的一个”碎片”，就是一个独立成立、保持自身完整性的单元；它可以和其他的OOP”碎片”整合在一起形成一个可分解的指令结构。 “对象”限制了程序漏洞所能造成的损害，有效地对功能实行了隔离，把每个功能都限制在一个可掌控的单元内，这样一来，即使一个对象崩溃了，程序的其他部分也能够继续运转。程序员可以把这个坏掉的单元换掉，就好像我们可以给一个汽车换刹车片一样。软件的销售商可以购买或者销售各种事先编制好的”对象”库给其他的软件研发人员，后者则可以基于这些库里的对象快速地组装起大型软件，而不用再像以前那样重新一行一行的编写新的代码。而到了要为这种大型软件升级的时候，你所要做的就是升级旧的对象或者加入新的对象。 再比如：我们做的app，它有许多的功能，每一个功能它对应一个模块。我们通过一个一个实现再把这些模块堆起来，通过我们的接口、方法、回调等把它们组合起来，最后形成我们的面向对象程序，也就是最后生成了我们的app。 模块自身应该是单一的、高内聚的，模块与模块之间应该是低耦合的 泛型 Java 1.5发行版本中增加了泛型(Generic)。 在没有泛型之前，从集合中读取到的每个对象都必须进行转换。如果有人不小心插入了类型错误的对象，在编译时是无法察觉的，在运行时的转换处理就会出错。有了泛型之后，可以告诉编译起每个集合中接受哪些对象类型。编译器自动地为你的插入进行转化，并在编译是告知是否插入了类型错误的对象。这样可以使程序既更加安全，又更加清楚。 每个泛型都定义一个原生态类型,即不带任何实际类型参数的泛型名称。例如，与List相对应的原生态类型是List。原生态类型就像从类型声明中删除了所有泛型信息一样。 请不要在新代码中使用原生类型，如果使用原生态类型，就失掉了泛型在安全性和表述性方面的所有优势。 sleep()和wait()的区别sleep()方法和wait()方法都成产生让当前运行的线程停止运行的效果，这是它们的共同点。 不同点： 最主要是sleep()没有释放锁，而wait()释放了锁，使得其他线程可以使用同步控制块或者方法。 wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用（使用范围） 1234synchronized(x)&#123; x.notify() //或者wait()&#125; 这两个方法来自不同的类分别是Thread和Object sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常 JAVA反射机制 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 Java反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态代理。 weak/soft/strong引用的区别 强引用(StrongReference) 是 Java 的默认引用实现, 它会一直存活于 JVM 内， 直到没有任何对象指向它时 GC 执行后才会被回收 弱引用(WeakReference)， 顾名思义, 是一个弱引用, 当所引用的对象在 JVM 内不再有强引用时, GC 后 weak reference 将会被自动回收 软引用SoftReference 于 WeakReference 的特性基本一致， 最大的区别在于 SoftReference 会尽可能长的保留引用直到 JVM 内存不足时才会被回收(虚拟机保证), 这一特性使得 SoftReference 非常适合缓存应用 Object的hashCode()与equals()的区别和作用equals(Object obj)方法用来判断两个对象是否“相同”，如果“相同”则返回true，否则返回false。hashcode()方法返回一个int数，在Object类中的默认实现是“将该对象的内部地址转换成一个整数返回”。 在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话，就会违反Object.hashCode的通用约定，从而导致该类无法结合所有基于hashCode的集合一起正常运作，这些集合包含HashMap，HashSet,HashTable。 这些集合通过对象的hashCode和equals方法判断集合中是否已存着该对象。 约定：如果两个对象相同，那么他们的hashcode一定相等，如果两个对象不相同，他们的hashcode可能相同。 伪代码如下： 123456 if(obj1.hashCode()==obj2.hashCode())&#123; if(obj1.equals(obj2))&#123; // 集合中已存在该元素； &#125; &#125;//集合中不存着该元素]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Glide加载圆形image第一次只显示占位图的坑]]></title>
    <url>%2F2017%2F01%2F21%2FGlideLoadedCircularImageBug%2F</url>
    <content type="text"><![CDATA[Glide加载圆形image第一次只显示占位图的坑在使用Glide加载图片时，经常出现图片加载不出来，只显示占位图的情况。 随后我好好的分析了这个问题的触发场景： 出现此问题的ImageView都是CircleImageView，其他ImageView的一切正常 出现此问题的ImagView都设置了占位图，不设置一切正常 出现此问题的ImagView加载时都使用了Glide的渐显动画，不使用一切正常 所以如果你刚好使用了CircleImageView或者其他的一些自定义的圆形Imageview，而你又刚好设置了占位图的话，那么，你就会遇到这个问题。 解决方案方案一：不设置占位图；方案二：使用Glide的Transformation API自定义圆形Bitmap的转换。方案三：使用下面的代码加载图片：123456789Glide.with(mContext) .load(url) .placeholder(R.drawable.ic_default_avatar) .into(new SimpleTarget&lt;Bitmap&gt;(width, height) &#123; @Override public void onResourceReady(Bitmap bitmap, GlideAnimation anim) &#123; circleImageView.setImageDrawable(resource); &#125; &#125;); 方案四：不使用Glide的默认动画：12345Glide.with(mContext) .load(url) .dontAnimate() .placeholder(R.drawable.ic_default_avatar) .into(circleImageview);]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OkHttp在4.4及以下不支持TLS协议的解决方法]]></title>
    <url>%2F2017%2F01%2F21%2Fhttps-Exception%2F</url>
    <content type="text"><![CDATA[在发布水滴preview版的的过程中，5.0以下的手机都不能访问网络。 错误信息如下： 12345javax.net.ssl.SSLHandshakeException: javax.net.ssl.SSLProtocolException: SSL handshake aborted: ssl=0x79f145b0:Failure in SSL library, usually a protocol error error:1407742E:SSL routines:SSL23_GET_SERVER_HELLO:tlsv1 alert protocol version 因为之前没有太多接触过网络协议，这个问题也确实很难搜到，所以我找了很久，才找到了原因：Android 4.4及以下的系统默认不支持TLS协议，所以遇到使用TLS协议的网站就无法访问了。 解决方法如下：创建一个SSLSocketFactoryCompat.java文件，内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140package com.earlydata.waterdrop.data.net;import android.os.Build;import java.io.IOException;import java.net.InetAddress;import java.net.Socket;import java.net.UnknownHostException;import java.security.GeneralSecurityException;import java.util.Arrays;import java.util.HashSet;import java.util.LinkedList;import java.util.List;import javax.net.ssl.SSLContext;import javax.net.ssl.SSLSocket;import javax.net.ssl.SSLSocketFactory;import javax.net.ssl.X509TrustManager;public class SSLSocketFactoryCompat extends SSLSocketFactory &#123; private SSLSocketFactory defaultFactory; // Android 5.0+ (API level21) provides reasonable default settings // but it still allows SSLv3 // https://developer.android.com/about/versions/android-5.0-changes.html#ssl static String protocols[] = null, cipherSuites[] = null; static &#123; try &#123; SSLSocket socket = (SSLSocket)SSLSocketFactory.getDefault().createSocket(); if (socket != null) &#123; /* set reasonable protocol versions */ // - enable all supported protocols (enables TLSv1.1 and TLSv1.2 on Android &lt;5.0) // - remove all SSL versions (especially SSLv3) because they're insecure now List&lt;String&gt; protocols = new LinkedList&lt;&gt;(); for (String protocol : socket.getSupportedProtocols()) if (!protocol.toUpperCase().contains("SSL")) protocols.add(protocol); SSLSocketFactoryCompat.protocols = protocols.toArray(new String[protocols.size()]); /* set up reasonable cipher suites */ if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123; // choose known secure cipher suites List&lt;String&gt; allowedCiphers = Arrays.asList( // TLS 1.2 "TLS_RSA_WITH_AES_256_GCM_SHA384", "TLS_RSA_WITH_AES_128_GCM_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", "TLS_ECHDE_RSA_WITH_AES_128_GCM_SHA256", // maximum interoperability "TLS_RSA_WITH_3DES_EDE_CBC_SHA", "TLS_RSA_WITH_AES_128_CBC_SHA", // additionally "TLS_RSA_WITH_AES_256_CBC_SHA", "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA", "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA", "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"); List&lt;String&gt; availableCiphers = Arrays.asList(socket.getSupportedCipherSuites()); // take all allowed ciphers that are available and put them into preferredCiphers HashSet&lt;String&gt; preferredCiphers = new HashSet&lt;&gt;(allowedCiphers); preferredCiphers.retainAll(availableCiphers); /* For maximum security, preferredCiphers should *replace* enabled ciphers (thus disabling * ciphers which are enabled by default, but have become unsecure), but I guess for * the security level of DAVdroid and maximum compatibility, disabling of insecure * ciphers should be a server-side task */ // add preferred ciphers to enabled ciphers HashSet&lt;String&gt; enabledCiphers = preferredCiphers; enabledCiphers.addAll(new HashSet&lt;&gt;(Arrays.asList(socket.getEnabledCipherSuites()))); SSLSocketFactoryCompat.cipherSuites = enabledCiphers.toArray(new String[enabledCiphers.size()]); &#125; &#125; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; public SSLSocketFactoryCompat(X509TrustManager tm) &#123; try &#123; SSLContext sslContext = SSLContext.getInstance("TLS"); sslContext.init(null, (tm != null) ? new X509TrustManager[] &#123; tm &#125; : null, null); defaultFactory = sslContext.getSocketFactory(); &#125; catch (GeneralSecurityException e) &#123; throw new AssertionError(); // The system has no TLS. Just give up. &#125; &#125; private void upgradeTLS(SSLSocket ssl) &#123; // Android 5.0+ (API level21) provides reasonable default settings // but it still allows SSLv3 // https://developer.android.com/about/versions/android-5.0-changes.html#ssl if (protocols != null) &#123; ssl.setEnabledProtocols(protocols); &#125; if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP &amp;&amp; cipherSuites != null) &#123; ssl.setEnabledCipherSuites(cipherSuites); &#125; &#125; @Override public String[] getDefaultCipherSuites() &#123; return cipherSuites; &#125; @Override public String[] getSupportedCipherSuites() &#123; return cipherSuites; &#125; @Override public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException &#123; Socket ssl = defaultFactory.createSocket(s, host, port, autoClose); if (ssl instanceof SSLSocket) upgradeTLS((SSLSocket)ssl); return ssl; &#125; @Override public Socket createSocket(String host, int port) throws IOException, UnknownHostException &#123; Socket ssl = defaultFactory.createSocket(host, port); if (ssl instanceof SSLSocket) upgradeTLS((SSLSocket)ssl); return ssl; &#125; @Override public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException &#123; Socket ssl = defaultFactory.createSocket(host, port, localHost, localPort); if (ssl instanceof SSLSocket) upgradeTLS((SSLSocket)ssl); return ssl; &#125; @Override public Socket createSocket(InetAddress host, int port) throws IOException &#123; Socket ssl = defaultFactory.createSocket(host, port); if (ssl instanceof SSLSocket) upgradeTLS((SSLSocket)ssl); return ssl; &#125; @Override public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException &#123; Socket ssl = defaultFactory.createSocket(address, port, localAddress, localPort); if (ssl instanceof SSLSocket) upgradeTLS((SSLSocket)ssl); return ssl; &#125;&#125; 在创建OkHttpClient的时候，添加这个SSLSocketFactory（我用单例模式来每次获取同一个全局的OkHttpClient，每个人的实现不一定一样，从我的代码里参考问题的解决方法就好）： 1234567891011121314151617181920OkHttpClient.Builder clientBuilder = new OkHttpClient.Builder(); // 自定义一个信任所有证书的TrustManager，添加SSLSocketFactory的时候要用到 final X509TrustManager trustAllCert = new X509TrustManager() &#123; @Override public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public java.security.cert.X509Certificate[] getAcceptedIssuers() &#123; return new java.security.cert.X509Certificate[]&#123;&#125;; &#125; &#125;;SSLSocketFactory sslSocketFactory = new SSLSocketFactoryCompat(trustAllCert);clientBuilder.sslSocketFactory(sslSocketFactory, trustAllCert); 这样就可以解决了～]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何遍写测试用例]]></title>
    <url>%2F2017%2F01%2F20%2Farticle-title%2F</url>
    <content type="text"><![CDATA[如何遍写测试用例测试代码主要分为java单元测试用例和Android测试用例。 java单元测试用例 ： 主要是业务逻辑和数据相关，独立于Android 不需要跑在 Android 设备上 Android 测试用例 ： 主要是UI相关，这类 case 必须要运行在 android 设备上 哪些东西需要测试呢？ 所有的Model、Presenter/ViewModel、Api、Utils等类的public方法 Data类除了getter、setter、toString、hashCode等一般自动生成的方法之外的逻辑部分 自定义View的功能：比如set data以后，text有没有显示出来等等，简单的交互，比如click事件，负责的交互一般不测，比如touch、滑动事件等等。 Activity的主要功能：比如view是不是存在、显示数据、错误信息、简单的点击事件等。比较复杂的用户交互比如onTouch，以及view的样式、位置等等可以不测。因为不好测。 在Android Studio中进行单元测试并不需要什么插件或者过多的配置，Android Studio本身就集成了测试环境，无论是单纯的java代码单元测试还是依赖Android SDK的Android代码单元测试，都能得心应手。 首先在你的gradle中加入Junit的依赖，注意这里的依赖方式是测试期间的依赖（testCompile）：123dependencies &#123; testCompile 'junit:junit:4.12'&#125; 默认建立的结构如下： 编写Java测试用例如果所写的测试代码没有使用android sdk（android.*下的代码），那么可以在test目录下新建，本例中即为ExampleUnitTest，例子中测试了一个RxJava的Observable的发射后被消费的结果。 注意测试用例即一个public void的方法，并且加上@Test注解，这是Junit的标准用法 123456789101112131415161718192021222324252627282930package com.earlydata.waterdrop;import org.junit.Test;import rx.Observer;import rx.subjects.PublishSubject;public class ExampleUnitTest &#123; @Test public void testPublishSubject() &#123; PublishSubject&lt;String&gt; stringPublishSubject = PublishSubject.create(); stringPublishSubject.subscribe(new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("Observable completed"); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; System.out.println("Observer consumed " + s); &#125; &#125;); stringPublishSubject.onNext("hello world"); stringPublishSubject.onCompleted(); &#125;&#125; 这时候打开Android Studio左边的Structure的面板，可以看到测试用例方法testPublishSubject 右击并运行它，测试通过，返回了正确的值 注意本测试用例试用了System.out.println所以测试结果直接打印在了控制台上，如果把打印的地方换成Log.d()呢，你会发现报错： 这个实际是因为你在java的Unit test中引用了Android的代码，即android.util.log.Log。所以对于测试Android代码，需要在androidTest中 编写Android测试用例Android 测试用例主要是对Espresso API的使用，以下系列文章是对Espresso官方文档的翻译(偷个懒) 1. Espresso 概览 2. Espresso 设置说明 3. Espresso 基础 4. Espresso 备忘录 5. Espresso 意图 6. Espresso 高级示例 7. Espresso Web 8. AndroidJUnitRunner 9. ATSL 中的 JUnit4 规则 10. UI Automator 11. 可访问性检查 其他资料 关于安卓单元测试，你需要知道的一切 使用 Espresso 进行 Android UI 测试 Android UI 测试框架 Espresso Android 测试代码编写小技巧 - UI 和 单元测试间共享代码]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用Github搭建自己的博客]]></title>
    <url>%2F2017%2F01%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[本人一直都泡在CSDN，简书，知乎等论坛，爱关注大牛博客。 看了《手把手教你用Hexo+Github 搭建属于自己的博客》之后决定搭建自己的博客，开始养成写博客的习惯。 写文章会锻炼许多对于编程十分有益的技能。即使没人读我的文章，写作的过程也是有益无害。它能帮助我理清思路，明确对于某个问题的看法，加强或削弱我的某种观点。把凌乱的想法汇聚成精简的文字非常有价值。]]></content>
  </entry>
</search>